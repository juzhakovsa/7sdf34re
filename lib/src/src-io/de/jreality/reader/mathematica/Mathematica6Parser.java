// $ANTLR 2.7.7 (2006-11-01): "mathematica6.g" -> "Mathematica6Parser.java"$

/**
* this code is generated by ANTLR from the 'mathematica6.g'-file
* @author Bernd Gonska
* @version 1.0
*/
package de.jreality.reader.mathematica;
import java.util.*;
import java.util.List;
import java.util.ArrayList;
import de.jreality.geometry.*;
import de.jreality.scene.data.*;
import de.jreality.scene.*;
import de.jreality.scene.SceneGraphComponent;
import de.jreality.shader.Color;
import de.jreality.util.LoggingSystem;
import java.util.logging.Level;
import java.util.logging.Logger;

import antlr.TokenBuffer;
import antlr.TokenStreamException;
import antlr.TokenStreamIOException;
import antlr.ANTLRException;
import antlr.LLkParser;
import antlr.Token;
import antlr.TokenStream;
import antlr.RecognitionException;
import antlr.NoViableAltException;
import antlr.MismatchedTokenException;
import antlr.SemanticException;
import antlr.ParserSharedInputState;
import antlr.collections.impl.BitSet;

public class Mathematica6Parser extends antlr.LLkParser       implements Mathematica6ParserTokenTypes
 {

/**
* wandelt Graphic3D- Objekte die aus Mathematica mittels 
* 			<Graphics3D -Object> >> <Pfad>\ <fileName.m>
* herausgeschrieben wurden in einen SceneGraphen von JReality um.
*
* Die Daten haben im file folgende Form(sind uebrigens direkter Mathematica-Text):
* Graphics3D[ {} , {} ]
* in der ersten Klammer steht ein "{..}"-Klammer Baum von gemischten Listen aus 
* graphischen Objekten und graphischen Directiven( wie Farben ect.)
* Bsp: Graphics3D[ 		{o1,o2,d1,{d2,o3,{o4},d3,o5}} 			,{} ]   
*					(d1-d3 Directiven , o1-o5 graphische Objekte)
* in der 2. Klammer steht eine Liste von Optionen die die ganze Scene beinflussen sollen.
* Bsp: Graphics3D[ 		{o1,o2,d1,{d2,o3,{o4},d3,o5}} 			,{Op1,Opt2,..} ]
*
* Vorgehen: 
* erste Klammer:
*		Klammern werden zu SceneGraphComponents die den Inhalt als Unterbaeume tragen.
* 		die graphischen Objekte werden je zu einer SceneGr.C. mit entsprechender Geometrie
*		die graphischen Directiven werden in der jeweils betroffenen Geometrie gesetzt(Farben)
*				manche Directiven werden ueberlesen!!!
* zweite Klammer:
*		alle Optionen werden ueberlesen!!!
*
* Problem: manchmal werden Coordinaten so ausgerechnet das sie noch einen 
*	 Imaginaerteil haben ( meist = 0) der noch dahinter steht
*	Loesung :ein + ...*I ignorieren!
*			   Doubles werden ja immer durch "," getrennt! Also geht das!
*/

	// this is what is returned from the parsing process
	private SceneGraphComponent root = new SceneGraphComponent();	
	private SceneGraphComponent current = root;		// aktuell zu erweiternder Knoten 
	private MState initialState=new MState();
	private Logger log = LoggingSystem.getLogger(Mathematica6Parser.class);
	private Appearance startApp =new Appearance();

// -------------------------------- default Lights ----------------------------
	public static SceneGraphComponent getDefaultLightNode (){
		return	MathematicaHelper.getDefaultLightNode();
	} 

/**
* konstructs a parser who can translate a
* mathematica-file to the corresponding SceneGraph
* @param    see superclass
* example: Mathematica6Parser p=
*	    new Mathematica6Parser(new Mathematica6Lexer(
*	     new FileReader(new File("file.m"))));
*/

protected Mathematica6Parser(TokenBuffer tokenBuf, int k) {
  super(tokenBuf,k);
  tokenNames = _tokenNames;
}

public Mathematica6Parser(TokenBuffer tokenBuf) {
  this(tokenBuf,3);
}

protected Mathematica6Parser(TokenStream lexer, int k) {
  super(lexer,k);
  tokenNames = _tokenNames;
}

public Mathematica6Parser(TokenStream lexer) {
  this(lexer,3);
}

public Mathematica6Parser(ParserSharedInputState state) {
  super(state,3);
  tokenNames = _tokenNames;
}

/**
* starts the parsing Process
* @param none sourcefile set by creating the object
* @returns SceneGraphComponent root of generated scene
*/
	public final SceneGraphComponent  start() throws RecognitionException, TokenStreamException {
		SceneGraphComponent r=new SceneGraphComponent();
		
		
			root.setName("Mathematica6");
			log.setLevel(Level.FINE);	
		
		
		try {      // for error handling
			{
			switch ( LA(1)) {
			case 7:
			{
				graphics3D();
				break;
			}
			case OPEN_BRACE:
			{
				match(OPEN_BRACE);
				listOfGraphics3D();
				match(CLOSE_BRACE);
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			r=root;
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_0);
		}
		return r;
	}
	
	private final void graphics3D() throws RecognitionException, TokenStreamException {
		
		System.out.println("graphics3D");
		
		try {      // for error handling
			match(7);
			match(OPEN_BRACKET);
								
						// neuen Knoten erstellen der die Listenelemente enthaelt, 
						SceneGraphComponent newPart = new SceneGraphComponent();
						newPart.setName("Graphic");
						SceneGraphComponent oldPart = current;
						current.addChild(newPart);
						current=newPart;
						MState state2=initialState.copy();
					
			{
			if ((LA(1)==OPEN_BRACE) && (_tokenSet_1.member(LA(2))) && (_tokenSet_2.member(LA(3)))) {
				match(OPEN_BRACE);
				objectListG3D(state2);
				match(CLOSE_BRACE);
				{
				switch ( LA(1)) {
				case COLON:
				{
					match(COLON);
					waste();
					break;
				}
				case CLOSE_BRACKET:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
			}
			else if ((_tokenSet_1.member(LA(1))) && (_tokenSet_3.member(LA(2))) && (_tokenSet_4.member(LA(3)))) {
				objectListG3D(state2);
			}
			else if ((LA(1)==CLOSE_BRACKET)) {
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			
			}
			match(CLOSE_BRACKET);
			current=oldPart;
					System.out.println("done");
					
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_5);
		}
	}
	
	private final void listOfGraphics3D() throws RecognitionException, TokenStreamException {
		
		System.out.println("listOfGraphics3D");
		
		try {      // for error handling
			{
			switch ( LA(1)) {
			case OPEN_BRACE:
			case 7:
			{
				{
				switch ( LA(1)) {
				case 7:
				{
					graphics3D();
					break;
				}
				case OPEN_BRACE:
				{
					match(OPEN_BRACE);
					listOfGraphics3D();
					match(CLOSE_BRACE);
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				{
				switch ( LA(1)) {
				case COLON:
				{
					match(COLON);
					listOfGraphics3D();
					break;
				}
				case CLOSE_BRACE:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				break;
			}
			case CLOSE_BRACE:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_6);
		}
	}
	
	private final void objectListG3D(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		MState state2=state.copy(); 
		System.out.println("objectList");
		
		
		try {      // for error handling
			{
			switch ( LA(1)) {
			case OPEN_BRACE:
			{
				listG3D(state2);
				break;
			}
			case LITERAL_GraphicsGroup:
			case LITERAL_Cuboid:
			case LITERAL_Sphere:
			case LITERAL_Cylinder:
			case LITERAL_Text:
			case LITERAL_Inset:
			case LITERAL_GraphicsComplex:
			case LITERAL_Point:
			case LITERAL_Line:
			case LITERAL_Tube:
			case LITERAL_Polygon:
			case LITERAL_SurfaceColor:
			case LITERAL_Red:
			case LITERAL_Green:
			case LITERAL_Blue:
			case LITERAL_Black:
			case LITERAL_White:
			case LITERAL_Gray:
			case LITERAL_Cyan:
			case LITERAL_Magenta:
			case LITERAL_Yellow:
			case LITERAL_Brown:
			case LITERAL_Orange:
			case LITERAL_Pink:
			case LITERAL_Purple:
			case LITERAL_LightRed:
			case LITERAL_LightGreen:
			case LITERAL_LightBlue:
			case LITERAL_LightGray:
			case LITERAL_LightCyan:
			case LITERAL_LightMagenta:
			case LITERAL_LightYellow:
			case LITERAL_LightBrown:
			case LITERAL_LightOrange:
			case LITERAL_LightPink:
			case LITERAL_LightPurple:
			case LITERAL_Lighter:
			case LITERAL_Darker:
			case LITERAL_RGBColor:
			case LITERAL_Hue:
			case LITERAL_GrayLevel:
			case LITERAL_CMYKColor:
			case LITERAL_Opacity:
			case LITERAL_Directive:
			case LITERAL_EdgeForm:
			case LITERAL_FaceForm:
			case LITERAL_ContentSelectable:
			case LITERAL_None:
			case LITERAL_Arrow:
			case LITERAL_AbsoluteDashing:
			case LITERAL_AbsolutePointSize:
			case LITERAL_AbsoluteThickness:
			case LITERAL_Arrowheads:
			case LITERAL_Annotation:
			case LITERAL_AlignmentPoint:
			case LITERAL_AspectRatio:
			case LITERAL_Axes:
			case LITERAL_AxesEdge:
			case LITERAL_AxesLabel:
			case LITERAL_AxesOrigin:
			case LITERAL_AxesStyle:
			case LITERAL_AmbientLight:
			case LITERAL_BezierCurve:
			case LITERAL_BSplineCurve:
			case LITERAL_BSplineSurface:
			case LITERAL_Button:
			case LITERAL_Background:
			case LITERAL_BaselinePosition:
			case LITERAL_BaseStyle:
			case LITERAL_Boxed:
			case LITERAL_BoxRatios:
			case LITERAL_BoxStyle:
			case LITERAL_CapForm:
			case LITERAL_ControllerLinking:
			case LITERAL_ControllerMethod:
			case LITERAL_ControllerPath:
			case LITERAL_ColorOutput:
			case LITERAL_Dashing:
			case LITERAL_Dynamic:
			case LITERAL_DisplayFunction:
			case LITERAL_DefaultColor:
			case LITERAL_DefaultFont:
			case LITERAL_Epilog:
			case LITERAL_EventHandler:
			case LITERAL_FaceGrids:
			case LITERAL_FaceGridsStyle:
			case LITERAL_FormatType:
			case LITERAL_Hyperlink:
			case LITERAL_ImageMargins:
			case LITERAL_ImagePadding:
			case LITERAL_ImageSize:
			case LITERAL_JoinForm:
			case LITERAL_Lighting:
			case LITERAL_LightSources:
			case LITERAL_LabelStyle:
			case LITERAL_Mouseover:
			case LITERAL_Method:
			case LITERAL_Prolog:
			case LITERAL_PlotRange:
			case LITERAL_PlotRangePadding:
			case LITERAL_PlotLabel:
			case LITERAL_PlotRegion:
			case LITERAL_PointSize:
			case LITERAL_PolygonIntersections:
			case 128:
			case LITERAL_PopupWindow:
			case LITERAL_PreserveImageOptions:
			case LITERAL_RenderAll:
			case LITERAL_RotationAction:
			case LITERAL_SphericalRegion:
			case LITERAL_Shading:
			case LITERAL_Spec:
			case LITERAL_Specularity:
			case LITERAL_StatusArea:
			case LITERAL_Style:
			case LITERAL_Ticks:
			case LITERAL_TicksStyle:
			case LITERAL_Tooltip:
			case LITERAL_TextStyle:
			case LITERAL_Thickness:
			case LITERAL_ViewPoint:
			case LITERAL_ViewAngle:
			case LITERAL_ViewCenter:
			case LITERAL_ViewVertical:
			case LITERAL_ViewMatrix:
			case LITERAL_ViewRange:
			case LITERAL_ViewVector:
			{
				objectG3D(state2);
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			{
			_loop14:
			do {
				if ((LA(1)==COLON)) {
					match(COLON);
					{
					switch ( LA(1)) {
					case OPEN_BRACE:
					{
						listG3D(state2);
						break;
					}
					case LITERAL_GraphicsGroup:
					case LITERAL_Cuboid:
					case LITERAL_Sphere:
					case LITERAL_Cylinder:
					case LITERAL_Text:
					case LITERAL_Inset:
					case LITERAL_GraphicsComplex:
					case LITERAL_Point:
					case LITERAL_Line:
					case LITERAL_Tube:
					case LITERAL_Polygon:
					case LITERAL_SurfaceColor:
					case LITERAL_Red:
					case LITERAL_Green:
					case LITERAL_Blue:
					case LITERAL_Black:
					case LITERAL_White:
					case LITERAL_Gray:
					case LITERAL_Cyan:
					case LITERAL_Magenta:
					case LITERAL_Yellow:
					case LITERAL_Brown:
					case LITERAL_Orange:
					case LITERAL_Pink:
					case LITERAL_Purple:
					case LITERAL_LightRed:
					case LITERAL_LightGreen:
					case LITERAL_LightBlue:
					case LITERAL_LightGray:
					case LITERAL_LightCyan:
					case LITERAL_LightMagenta:
					case LITERAL_LightYellow:
					case LITERAL_LightBrown:
					case LITERAL_LightOrange:
					case LITERAL_LightPink:
					case LITERAL_LightPurple:
					case LITERAL_Lighter:
					case LITERAL_Darker:
					case LITERAL_RGBColor:
					case LITERAL_Hue:
					case LITERAL_GrayLevel:
					case LITERAL_CMYKColor:
					case LITERAL_Opacity:
					case LITERAL_Directive:
					case LITERAL_EdgeForm:
					case LITERAL_FaceForm:
					case LITERAL_ContentSelectable:
					case LITERAL_None:
					case LITERAL_Arrow:
					case LITERAL_AbsoluteDashing:
					case LITERAL_AbsolutePointSize:
					case LITERAL_AbsoluteThickness:
					case LITERAL_Arrowheads:
					case LITERAL_Annotation:
					case LITERAL_AlignmentPoint:
					case LITERAL_AspectRatio:
					case LITERAL_Axes:
					case LITERAL_AxesEdge:
					case LITERAL_AxesLabel:
					case LITERAL_AxesOrigin:
					case LITERAL_AxesStyle:
					case LITERAL_AmbientLight:
					case LITERAL_BezierCurve:
					case LITERAL_BSplineCurve:
					case LITERAL_BSplineSurface:
					case LITERAL_Button:
					case LITERAL_Background:
					case LITERAL_BaselinePosition:
					case LITERAL_BaseStyle:
					case LITERAL_Boxed:
					case LITERAL_BoxRatios:
					case LITERAL_BoxStyle:
					case LITERAL_CapForm:
					case LITERAL_ControllerLinking:
					case LITERAL_ControllerMethod:
					case LITERAL_ControllerPath:
					case LITERAL_ColorOutput:
					case LITERAL_Dashing:
					case LITERAL_Dynamic:
					case LITERAL_DisplayFunction:
					case LITERAL_DefaultColor:
					case LITERAL_DefaultFont:
					case LITERAL_Epilog:
					case LITERAL_EventHandler:
					case LITERAL_FaceGrids:
					case LITERAL_FaceGridsStyle:
					case LITERAL_FormatType:
					case LITERAL_Hyperlink:
					case LITERAL_ImageMargins:
					case LITERAL_ImagePadding:
					case LITERAL_ImageSize:
					case LITERAL_JoinForm:
					case LITERAL_Lighting:
					case LITERAL_LightSources:
					case LITERAL_LabelStyle:
					case LITERAL_Mouseover:
					case LITERAL_Method:
					case LITERAL_Prolog:
					case LITERAL_PlotRange:
					case LITERAL_PlotRangePadding:
					case LITERAL_PlotLabel:
					case LITERAL_PlotRegion:
					case LITERAL_PointSize:
					case LITERAL_PolygonIntersections:
					case 128:
					case LITERAL_PopupWindow:
					case LITERAL_PreserveImageOptions:
					case LITERAL_RenderAll:
					case LITERAL_RotationAction:
					case LITERAL_SphericalRegion:
					case LITERAL_Shading:
					case LITERAL_Spec:
					case LITERAL_Specularity:
					case LITERAL_StatusArea:
					case LITERAL_Style:
					case LITERAL_Ticks:
					case LITERAL_TicksStyle:
					case LITERAL_Tooltip:
					case LITERAL_TextStyle:
					case LITERAL_Thickness:
					case LITERAL_ViewPoint:
					case LITERAL_ViewAngle:
					case LITERAL_ViewCenter:
					case LITERAL_ViewVertical:
					case LITERAL_ViewMatrix:
					case LITERAL_ViewRange:
					case LITERAL_ViewVector:
					{
						objectG3D(state2);
						break;
					}
					default:
					{
						throw new NoViableAltException(LT(1), getFilename());
					}
					}
					}
				}
				else {
					break _loop14;
				}
				
			} while (true);
			}
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_7);
		}
	}
	
	private final void waste() throws RecognitionException, TokenStreamException {
		
		
		try {      // for error handling
			{
			_loop161:
			do {
				if ((_tokenSet_8.member(LA(1)))) {
					{
					match(_tokenSet_8);
					}
				}
				else {
					break _loop161;
				}
				
			} while (true);
			}
			{
			switch ( LA(1)) {
			case OPEN_BRACE:
			{
				match(OPEN_BRACE);
				waste();
				match(CLOSE_BRACE);
				waste();
				break;
			}
			case OPEN_BRACKET:
			{
				match(OPEN_BRACKET);
				waste();
				match(CLOSE_BRACKET);
				waste();
				break;
			}
			case LPAREN:
			{
				match(LPAREN);
				waste();
				match(RPAREN);
				waste();
				break;
			}
			case CLOSE_BRACE:
			case CLOSE_BRACKET:
			case RPAREN:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_9);
		}
	}
	
	private final void listG3D(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		
		System.out.println("list");
		MState state2=state.copy(); 
		
		
		try {      // for error handling
			match(OPEN_BRACE);
									
						// neuen Knoten erstellen der die Listenelemente haelt, 
						SceneGraphComponent newPart = new SceneGraphComponent();
						newPart.setName("Object");
						SceneGraphComponent oldPart = current;
						current.addChild(newPart);
						current=newPart;
						
			{
			if ((_tokenSet_1.member(LA(1)))) {
				objectListG3D(state2);
			}
			else if ((LA(1)==CLOSE_BRACE)) {
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			
			}
			match(CLOSE_BRACE);
			
							current=oldPart;
						
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void objectG3D(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		
		// System.out.println("object");
		
		
		try {      // for error handling
			switch ( LA(1)) {
			case LITERAL_GraphicsGroup:
			{
				graphGroupG3D(state);
				break;
			}
			case LITERAL_Cuboid:
			{
				cuboid(state);
				break;
			}
			case LITERAL_Cylinder:
			{
				cylinder(state);
				break;
			}
			case LITERAL_Sphere:
			{
				sphere(state);
				break;
			}
			case LITERAL_Text:
			{
				text(state);
				break;
			}
			case LITERAL_Inset:
			{
				inset(state);
				break;
			}
			case LITERAL_GraphicsComplex:
			{
				graphComp(state);
				break;
			}
			case LITERAL_Point:
			{
				pointBlock(state);
				break;
			}
			case LITERAL_Line:
			case LITERAL_Tube:
			{
				lineBlock(state);
				break;
			}
			case LITERAL_Polygon:
			{
				polygonBlock(state);
				break;
			}
			default:
				if ((_tokenSet_11.member(LA(1))) && (_tokenSet_3.member(LA(2))) && (_tokenSet_4.member(LA(3)))) {
					directive(state);
				}
				else if ((_tokenSet_12.member(LA(1))) && (_tokenSet_3.member(LA(2))) && (_tokenSet_4.member(LA(3)))) {
					strange();
				}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void objectListGC(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		MState state2=state.copy(); 
		System.out.println("objectList");
		
		
		try {      // for error handling
			{
			if ((LA(1)==OPEN_BRACE)) {
				listGC(state2);
			}
			else if ((_tokenSet_13.member(LA(1)))) {
				objectGC(state2);
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			
			}
			{
			_loop19:
			do {
				if ((LA(1)==COLON)) {
					match(COLON);
					{
					if ((LA(1)==OPEN_BRACE)) {
						listGC(state2);
					}
					else if ((_tokenSet_13.member(LA(1)))) {
						objectGC(state2);
					}
					else {
						throw new NoViableAltException(LT(1), getFilename());
					}
					
					}
				}
				else {
					break _loop19;
				}
				
			} while (true);
			}
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_7);
		}
	}
	
	private final void listGC(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		
		System.out.println("list");
		MState state2=state.copy(); 
		
		
		try {      // for error handling
			match(OPEN_BRACE);
									
						// neuen Knoten erstellen der die Listenelemente haelt, 
						SceneGraphComponent newPart = new SceneGraphComponent();
						newPart.setName("Object");
						SceneGraphComponent oldPart = current;
						current.addChild(newPart);
						current=newPart;
						
			{
			if ((_tokenSet_14.member(LA(1)))) {
				objectListGC(state2);
			}
			else if ((LA(1)==CLOSE_BRACE)) {
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			
			}
			match(CLOSE_BRACE);
			
							current=oldPart;
						
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void objectGC(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		
		// System.out.println("object");
		
		
		try {      // for error handling
			switch ( LA(1)) {
			case LITERAL_GraphicsGroup:
			{
				graphGroupGC(state);
				break;
			}
			case LITERAL_Cuboid:
			{
				cuboid(state);
				break;
			}
			case LITERAL_Cylinder:
			{
				cylinder(state);
				break;
			}
			case LITERAL_Sphere:
			{
				sphere(state);
				break;
			}
			case LITERAL_Text:
			{
				text(state);
				break;
			}
			case LITERAL_Inset:
			{
				inset(state);
				break;
			}
			case LITERAL_GraphicsComplex:
			{
				graphComp(state);
				break;
			}
			case LITERAL_Point:
			{
				indexedPointSet(state);
				break;
			}
			case LITERAL_Line:
			case LITERAL_Tube:
			{
				indexedLineSet(state);
				break;
			}
			case LITERAL_Polygon:
			{
				indexedFaceSet(state);
				break;
			}
			default:
				if ((_tokenSet_11.member(LA(1))) && (_tokenSet_3.member(LA(2))) && ((LA(3) >= OPEN_BRACE && LA(3) <= WS_))) {
					directive(state);
				}
				else if ((LA(1)==LITERAL_ContentSelectable||LA(1)==LITERAL_VertexColors||LA(1)==LITERAL_VertexNormals) && (LA(2)==MINUS) && (LA(3)==LARGER)) {
					gcOpt(state);
				}
				else if ((_tokenSet_12.member(LA(1))) && (_tokenSet_3.member(LA(2))) && ((LA(3) >= OPEN_BRACE && LA(3) <= WS_))) {
					strange();
				}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void graphGroupG3D(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		
		MState state2=state.copy();
		System.out.println("graphGroup");
		
		
		try {      // for error handling
			match(LITERAL_GraphicsGroup);
			match(OPEN_BRACKET);
			{
			if ((_tokenSet_1.member(LA(1)))) {
				objectListG3D(state2);
			}
			else if ((LA(1)==CLOSE_BRACKET)) {
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			
			}
			match(CLOSE_BRACKET);
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void graphGroupGC(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		
		MState state2=state.copy();
		System.out.println("graphGroup");
		
		
		try {      // for error handling
			match(LITERAL_GraphicsGroup);
			match(OPEN_BRACKET);
			{
			if ((_tokenSet_14.member(LA(1)))) {
				objectListGC(state2);
			}
			else if ((LA(1)==CLOSE_BRACKET)) {
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			
			}
			match(CLOSE_BRACKET);
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void cuboid(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		
		System.out.println("cuboid");
		double[] v1 = new double []{0,0,0}; 
		double[] v2 = new double []{1,1,1}; 
		
		
		try {      // for error handling
			match(LITERAL_Cuboid);
			match(OPEN_BRACKET);
			{
			switch ( LA(1)) {
			case OPEN_BRACE:
			{
				v1=vektor();
				v2=new double[]{v1[0]+1,v1[1]+1,v1[2]+1};
				{
				switch ( LA(1)) {
				case COLON:
				{
					match(COLON);
					v2=vektor();
					break;
				}
				case CLOSE_BRACKET:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				break;
			}
			case CLOSE_BRACKET:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(CLOSE_BRACKET);
			current.addChild(state.makeCuboid(v1,v2));
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void cylinder(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		
		System.out.println("cylinder");
		double[] anfg=new double []{0,0,-1}; 
		double[] ende=new double []{0,0,1}; 
		double radius=1;
		int n=0;
		
		
		try {      // for error handling
			match(LITERAL_Cylinder);
			match(OPEN_BRACKET);
			{
			switch ( LA(1)) {
			case OPEN_BRACE:
			{
				match(OPEN_BRACE);
				{
				switch ( LA(1)) {
				case OPEN_BRACE:
				{
					anfg=vektor();
					break;
				}
				case MINUS:
				case PLUS:
				case INTEGER_THING:
				{
					n=indexVektor();
					anfg=state.getCoords(n);
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				match(COLON);
				{
				switch ( LA(1)) {
				case OPEN_BRACE:
				{
					ende=vektor();
					break;
				}
				case MINUS:
				case PLUS:
				case INTEGER_THING:
				{
					n=indexVektor();
					ende=state.getCoords(n);
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				match(CLOSE_BRACE);
				{
				switch ( LA(1)) {
				case COLON:
				{
					match(COLON);
					radius=doublething();
					break;
				}
				case CLOSE_BRACKET:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				break;
			}
			case CLOSE_BRACKET:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(CLOSE_BRACKET);
			// realisiert durch gestreckten Zylinder
						 current.addChild(state.makeCylinder(anfg,ende,radius));
						
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void sphere(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		
		System.out.println("sphere");
		double[] center=new double []{0,0,0}; 
		double radius=1;
		int n=0;
		
		
		try {      // for error handling
			match(LITERAL_Sphere);
			match(OPEN_BRACKET);
			{
			switch ( LA(1)) {
			case OPEN_BRACE:
			{
				center=vektor();
				{
				switch ( LA(1)) {
				case COLON:
				{
					match(COLON);
					radius=doublething();
					break;
				}
				case CLOSE_BRACKET:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				break;
			}
			case MINUS:
			case PLUS:
			case INTEGER_THING:
			{
				n=indexVektor();
				center=state.getCoords(n);
				{
				switch ( LA(1)) {
				case COLON:
				{
					match(COLON);
					radius=doublething();
					break;
				}
				case CLOSE_BRACKET:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				break;
			}
			case CLOSE_BRACKET:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(CLOSE_BRACKET);
			current.addChild(state.makeSphere(center,radius));	
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void text(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		Token  s = null;
		
		System.out.println("text");
		String expr="";
		double[] coords=new double[]{0,0,0};
		double[] offset=new double[]{0,0};
		double[] dir=new double[]{1,0};
		int n=0;
		
		
		try {      // for error handling
			match(LITERAL_Text);
			match(OPEN_BRACKET);
			s = LT(1);
			match(STRING);
			{
			switch ( LA(1)) {
			case COLON:
			{
				match(COLON);
				{
				switch ( LA(1)) {
				case OPEN_BRACE:
				{
					coords=vektor();
					break;
				}
				case MINUS:
				case PLUS:
				case INTEGER_THING:
				{
					n=indexVektor();
					coords=state.getCoords(n);
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				{
				switch ( LA(1)) {
				case COLON:
				{
					match(COLON);
					offset=vektordata2D();
					{
					switch ( LA(1)) {
					case COLON:
					{
						match(COLON);
						dir=vektordata2D();
						break;
					}
					case CLOSE_BRACKET:
					{
						break;
					}
					default:
					{
						throw new NoViableAltException(LT(1), getFilename());
					}
					}
					}
					break;
				}
				case CLOSE_BRACKET:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				break;
			}
			case CLOSE_BRACKET:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(CLOSE_BRACKET);
			
								 expr=s.getText();
								 // realisiert durch ein einelementiges Pointset mit einem LabelPunkt 
								 // mit verschwindend kleinem Radius!
								 current.addChild(state.makeLabel(expr,coords,offset,dir));
								
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void inset(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		System.out.println("inset");
		
		try {      // for error handling
			match(LITERAL_Inset);
			match(OPEN_BRACKET);
			waste();
			match(CLOSE_BRACKET);
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void graphComp(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		
		System.out.println("graphComp"); 
		MState state2=state.copy();
		double[][] coords;
		
		
		try {      // for error handling
			match(LITERAL_GraphicsComplex);
			match(OPEN_BRACKET);
			coords=vertexList();
			state2.coords=coords;
			match(COLON);
			{
			if ((_tokenSet_14.member(LA(1)))) {
				objectListGC(state2);
			}
			else if ((LA(1)==CLOSE_BRACKET)) {
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			
			}
			match(CLOSE_BRACKET);
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void pointBlock(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		
		System.out.println("pointBlock");
		List<double[]> points= new LinkedList<double[]>(); 
		double[] v = new double[3];
		
		
		try {      // for error handling
			match(LITERAL_Point);
			match(OPEN_BRACKET);
			{
			if ((LA(1)==OPEN_BRACE) && (_tokenSet_15.member(LA(2)))) {
				v=vektor();
				points.add(v);
			}
			else if ((LA(1)==OPEN_BRACE) && (LA(2)==OPEN_BRACE)) {
				match(OPEN_BRACE);
				v=vektor();
				points.add(v);
				{
				_loop53:
				do {
					if ((LA(1)==COLON)) {
						match(COLON);
						v=vektor();
						points.add(v);
					}
					else {
						break _loop53;
					}
					
				} while (true);
				}
				match(CLOSE_BRACE);
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			
			}
			{
			switch ( LA(1)) {
			case COLON:
			{
				match(COLON);
				waste();
				break;
			}
			case CLOSE_BRACKET:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(CLOSE_BRACKET);
			
					PointSetFactory psf = new PointSetFactory();
					double [][] coords = new double [points.size()][];
					int i=0;
					for(double[] d : points){
						coords[i]=d;
						i++;
					}
					psf.setVertexCount(coords.length);
					psf.setVertexCoordinates(coords);
					psf.update();
					SceneGraphComponent geo=new SceneGraphComponent();
					geo.setAppearance(state.getPointSetApp());
					PointSet p=psf.getPointSet();
					geo.setGeometry(p);
					geo.setName("Points");
					current.addChild(geo);
				
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void lineBlock(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		
		System.out.println("lineBlock");
		List<double[][]> lines=new LinkedList<double[][]>();
		double[][] line=null;
		int numVerts=0;
		
		
		try {      // for error handling
			{
			switch ( LA(1)) {
			case LITERAL_Line:
			{
				match(LITERAL_Line);
				break;
			}
			case LITERAL_Tube:
			{
				match(LITERAL_Tube);
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(OPEN_BRACKET);
			{
			if ((LA(1)==OPEN_BRACE) && (LA(2)==OPEN_BRACE) && (_tokenSet_15.member(LA(3)))) {
				line=vertexList();
				lines.add(line);numVerts+=line.length;
			}
			else if ((LA(1)==OPEN_BRACE) && (LA(2)==OPEN_BRACE) && (LA(3)==OPEN_BRACE)) {
				match(OPEN_BRACE);
				line=vertexList();
				lines.add(line);numVerts+=line.length;
				{
				_loop63:
				do {
					if ((LA(1)==COLON)) {
						match(COLON);
						line=vertexList();
						lines.add(line);numVerts+=line.length;
					}
					else {
						break _loop63;
					}
					
				} while (true);
				}
				match(CLOSE_BRACE);
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			
			}
			{
			switch ( LA(1)) {
			case COLON:
			{
				match(COLON);
				waste();
				break;
			}
			case CLOSE_BRACKET:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(CLOSE_BRACKET);
			
					IndexedLineSetFactory lineset=new IndexedLineSetFactory();
					double [][] coords=new double[numVerts][];
					int[][] indices= new int[lines.size()][];
					int laufNum=0;
					for(int i=0;i<lines.size();i++){
						line=lines.get(i);
						indices[i]=new int[line.length];
						for(int j=0; j<line.length;j++){
							indices[i][j]=laufNum;
							coords[laufNum]=line[j];
							laufNum++;
						}
					}
					lineset.setVertexCount(coords.length);
					lineset.setVertexCoordinates(coords);
					lineset.setEdgeCount(indices.length);
					lineset.setEdgeIndices(indices);
					lineset.update();
					SceneGraphComponent geo=new SceneGraphComponent();
					geo.setAppearance(state.getLineSetApp());
					IndexedLineSet ils=lineset.getIndexedLineSet();
					geo.setGeometry(ils);
					geo.setName("Lines");
					current.addChild(geo);
				
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void polygonBlock(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		
		System.out.println("polygonBlock");
		MState state2=state.copy(); 
		List<double[][]> faceList= new LinkedList<double[][]>();
		double[][] face;
		int numVerts=0;
		
		
		try {      // for error handling
			match(LITERAL_Polygon);
			match(OPEN_BRACKET);
			{
			if ((LA(1)==OPEN_BRACE) && (LA(2)==OPEN_BRACE) && (_tokenSet_15.member(LA(3)))) {
				face=vertexList();
				faceList.add(face);numVerts+=face.length;
			}
			else if ((LA(1)==OPEN_BRACE) && (LA(2)==OPEN_BRACE) && (LA(3)==OPEN_BRACE)) {
				match(OPEN_BRACE);
				face=vertexList();
				faceList.add(face);numVerts+=face.length;
				{
				_loop75:
				do {
					if ((LA(1)==COLON)) {
						match(COLON);
						face=vertexList();
						faceList.add(face);numVerts+=face.length;
					}
					else {
						break _loop75;
					}
					
				} while (true);
				}
				match(CLOSE_BRACE);
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			
			}
			{
			switch ( LA(1)) {
			case COLON:
			{
				match(COLON);
				waste();
				break;
			}
			case CLOSE_BRACKET:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(CLOSE_BRACKET);
			
					IndexedFaceSetFactory faceSet = new IndexedFaceSetFactory();
					double [][] coords=coords= new double[numVerts][];
					int[][] indices= new int[faceList.size()][];
					int laufNum=0;
					for(int i=0;i<faceList.size();i++){
						face=faceList.get(i);
						indices[i]=new int[face.length];
						for(int j=0; j<face.length;j++){
							indices[i][j]=laufNum;
							coords[laufNum]=face[j];
							laufNum++;
						}
					}
					faceSet.setVertexCount(coords.length);
					faceSet.setVertexCoordinates(coords);
					faceSet.setFaceCount(indices.length);
					faceSet.setFaceIndices(indices);
					faceSet.setGenerateFaceNormals(true);
					faceSet.update();		
					SceneGraphComponent geo=new SceneGraphComponent();	// Komponenten erstellen und einhaengen
					geo.setAppearance(state2.getFaceApp());
					IndexedFaceSet ifs= faceSet.getIndexedFaceSet();
					current.addChild(geo);
					geo.setName("Faces");
					geo.setGeometry(ifs);
					state.faces.add(ifs);
				
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void directive(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		System.out.println("directive");
		// Direktiven die die Appearance beeinflussen(keine Farben)
		// Bemerkung: Der Aufruf 'waste' ignoriert alles in der Klammer.
		Color col;
		
		try {      // for error handling
			switch ( LA(1)) {
			case LITERAL_SurfaceColor:
			case LITERAL_Red:
			case LITERAL_Green:
			case LITERAL_Blue:
			case LITERAL_Black:
			case LITERAL_White:
			case LITERAL_Gray:
			case LITERAL_Cyan:
			case LITERAL_Magenta:
			case LITERAL_Yellow:
			case LITERAL_Brown:
			case LITERAL_Orange:
			case LITERAL_Pink:
			case LITERAL_Purple:
			case LITERAL_LightRed:
			case LITERAL_LightGreen:
			case LITERAL_LightBlue:
			case LITERAL_LightGray:
			case LITERAL_LightCyan:
			case LITERAL_LightMagenta:
			case LITERAL_LightYellow:
			case LITERAL_LightBrown:
			case LITERAL_LightOrange:
			case LITERAL_LightPink:
			case LITERAL_LightPurple:
			case LITERAL_Lighter:
			case LITERAL_Darker:
			case LITERAL_RGBColor:
			case LITERAL_Hue:
			case LITERAL_GrayLevel:
			case LITERAL_CMYKColor:
			case LITERAL_Opacity:
			case LITERAL_Directive:
			{
				col=color(state);
				// Farbe fuer folgende Punkte, Linien und Texte
								  state.setColor(col);
								
				break;
			}
			case LITERAL_EdgeForm:
			{
				edgeForm(state);
				break;
			}
			case LITERAL_FaceForm:
			{
				faceForm(state);
				break;
			}
			case LITERAL_ContentSelectable:
			case LITERAL_None:
			case LITERAL_Arrow:
			case LITERAL_AbsoluteDashing:
			case LITERAL_AbsolutePointSize:
			case LITERAL_AbsoluteThickness:
			case LITERAL_Arrowheads:
			case LITERAL_Annotation:
			case LITERAL_AlignmentPoint:
			case LITERAL_AspectRatio:
			case LITERAL_Axes:
			case LITERAL_AxesEdge:
			case LITERAL_AxesLabel:
			case LITERAL_AxesOrigin:
			case LITERAL_AxesStyle:
			case LITERAL_AmbientLight:
			case LITERAL_BezierCurve:
			case LITERAL_BSplineCurve:
			case LITERAL_BSplineSurface:
			case LITERAL_Button:
			case LITERAL_Background:
			case LITERAL_BaselinePosition:
			case LITERAL_BaseStyle:
			case LITERAL_Boxed:
			case LITERAL_BoxRatios:
			case LITERAL_BoxStyle:
			case LITERAL_CapForm:
			case LITERAL_ControllerLinking:
			case LITERAL_ControllerMethod:
			case LITERAL_ControllerPath:
			case LITERAL_ColorOutput:
			case LITERAL_Dashing:
			case LITERAL_Dynamic:
			case LITERAL_DisplayFunction:
			case LITERAL_DefaultColor:
			case LITERAL_DefaultFont:
			case LITERAL_Epilog:
			case LITERAL_EventHandler:
			case LITERAL_FaceGrids:
			case LITERAL_FaceGridsStyle:
			case LITERAL_FormatType:
			case LITERAL_Hyperlink:
			case LITERAL_ImageMargins:
			case LITERAL_ImagePadding:
			case LITERAL_ImageSize:
			case LITERAL_JoinForm:
			case LITERAL_Lighting:
			case LITERAL_LightSources:
			case LITERAL_LabelStyle:
			case LITERAL_Mouseover:
			case LITERAL_Method:
			case LITERAL_Prolog:
			case LITERAL_PlotRange:
			case LITERAL_PlotRangePadding:
			case LITERAL_PlotLabel:
			case LITERAL_PlotRegion:
			case LITERAL_PointSize:
			case LITERAL_PolygonIntersections:
			case 128:
			case LITERAL_PopupWindow:
			case LITERAL_PreserveImageOptions:
			case LITERAL_RenderAll:
			case LITERAL_RotationAction:
			case LITERAL_SphericalRegion:
			case LITERAL_Shading:
			case LITERAL_Spec:
			case LITERAL_Specularity:
			case LITERAL_StatusArea:
			case LITERAL_Style:
			case LITERAL_Ticks:
			case LITERAL_TicksStyle:
			case LITERAL_Tooltip:
			case LITERAL_TextStyle:
			case LITERAL_Thickness:
			case LITERAL_ViewPoint:
			case LITERAL_ViewAngle:
			case LITERAL_ViewCenter:
			case LITERAL_ViewVertical:
			case LITERAL_ViewMatrix:
			case LITERAL_ViewRange:
			case LITERAL_ViewVector:
			{
				strange();
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void strange() throws RecognitionException, TokenStreamException {
		
		
		try {      // for error handling
			{
			switch ( LA(1)) {
			case LITERAL_Arrow:
			{
				match(LITERAL_Arrow);
				break;
			}
			case LITERAL_AbsoluteDashing:
			{
				match(LITERAL_AbsoluteDashing);
				break;
			}
			case LITERAL_AbsolutePointSize:
			{
				match(LITERAL_AbsolutePointSize);
				break;
			}
			case LITERAL_AbsoluteThickness:
			{
				match(LITERAL_AbsoluteThickness);
				break;
			}
			case LITERAL_Arrowheads:
			{
				match(LITERAL_Arrowheads);
				break;
			}
			case LITERAL_Annotation:
			{
				match(LITERAL_Annotation);
				break;
			}
			case LITERAL_AlignmentPoint:
			{
				match(LITERAL_AlignmentPoint);
				break;
			}
			case LITERAL_AspectRatio:
			{
				match(LITERAL_AspectRatio);
				break;
			}
			case LITERAL_Axes:
			{
				match(LITERAL_Axes);
				break;
			}
			case LITERAL_AxesEdge:
			{
				match(LITERAL_AxesEdge);
				break;
			}
			case LITERAL_AxesLabel:
			{
				match(LITERAL_AxesLabel);
				break;
			}
			case LITERAL_AxesOrigin:
			{
				match(LITERAL_AxesOrigin);
				break;
			}
			case LITERAL_AxesStyle:
			{
				match(LITERAL_AxesStyle);
				break;
			}
			case LITERAL_AmbientLight:
			{
				match(LITERAL_AmbientLight);
				break;
			}
			case LITERAL_BezierCurve:
			{
				match(LITERAL_BezierCurve);
				break;
			}
			case LITERAL_BSplineCurve:
			{
				match(LITERAL_BSplineCurve);
				break;
			}
			case LITERAL_BSplineSurface:
			{
				match(LITERAL_BSplineSurface);
				break;
			}
			case LITERAL_Button:
			{
				match(LITERAL_Button);
				break;
			}
			case LITERAL_Background:
			{
				match(LITERAL_Background);
				break;
			}
			case LITERAL_BaselinePosition:
			{
				match(LITERAL_BaselinePosition);
				break;
			}
			case LITERAL_BaseStyle:
			{
				match(LITERAL_BaseStyle);
				break;
			}
			case LITERAL_Boxed:
			{
				match(LITERAL_Boxed);
				break;
			}
			case LITERAL_BoxRatios:
			{
				match(LITERAL_BoxRatios);
				break;
			}
			case LITERAL_BoxStyle:
			{
				match(LITERAL_BoxStyle);
				break;
			}
			case LITERAL_CapForm:
			{
				match(LITERAL_CapForm);
				break;
			}
			case LITERAL_ContentSelectable:
			{
				match(LITERAL_ContentSelectable);
				break;
			}
			case LITERAL_ControllerLinking:
			{
				match(LITERAL_ControllerLinking);
				break;
			}
			case LITERAL_ControllerMethod:
			{
				match(LITERAL_ControllerMethod);
				break;
			}
			case LITERAL_ControllerPath:
			{
				match(LITERAL_ControllerPath);
				break;
			}
			case LITERAL_ColorOutput:
			{
				match(LITERAL_ColorOutput);
				break;
			}
			case LITERAL_Dashing:
			{
				match(LITERAL_Dashing);
				break;
			}
			case LITERAL_Dynamic:
			{
				match(LITERAL_Dynamic);
				break;
			}
			case LITERAL_DefaultColor:
			{
				match(LITERAL_DefaultColor);
				break;
			}
			case LITERAL_DefaultFont:
			{
				match(LITERAL_DefaultFont);
				break;
			}
			case LITERAL_Epilog:
			{
				match(LITERAL_Epilog);
				break;
			}
			case LITERAL_EventHandler:
			{
				match(LITERAL_EventHandler);
				break;
			}
			case LITERAL_FaceGrids:
			{
				match(LITERAL_FaceGrids);
				break;
			}
			case LITERAL_FaceGridsStyle:
			{
				match(LITERAL_FaceGridsStyle);
				break;
			}
			case LITERAL_FormatType:
			{
				match(LITERAL_FormatType);
				break;
			}
			case LITERAL_Hyperlink:
			{
				match(LITERAL_Hyperlink);
				break;
			}
			case LITERAL_ImageMargins:
			{
				match(LITERAL_ImageMargins);
				break;
			}
			case LITERAL_ImagePadding:
			{
				match(LITERAL_ImagePadding);
				break;
			}
			case LITERAL_ImageSize:
			{
				match(LITERAL_ImageSize);
				break;
			}
			case LITERAL_JoinForm:
			{
				match(LITERAL_JoinForm);
				break;
			}
			case LITERAL_Lighting:
			{
				match(LITERAL_Lighting);
				break;
			}
			case LITERAL_LightSources:
			{
				match(LITERAL_LightSources);
				break;
			}
			case LITERAL_LabelStyle:
			{
				match(LITERAL_LabelStyle);
				break;
			}
			case LITERAL_Mouseover:
			{
				match(LITERAL_Mouseover);
				break;
			}
			case LITERAL_Method:
			{
				match(LITERAL_Method);
				break;
			}
			case LITERAL_Prolog:
			{
				match(LITERAL_Prolog);
				break;
			}
			case LITERAL_PlotRange:
			{
				match(LITERAL_PlotRange);
				break;
			}
			case LITERAL_PlotRangePadding:
			{
				match(LITERAL_PlotRangePadding);
				break;
			}
			case LITERAL_PlotLabel:
			{
				match(LITERAL_PlotLabel);
				break;
			}
			case LITERAL_PlotRegion:
			{
				match(LITERAL_PlotRegion);
				break;
			}
			case LITERAL_PointSize:
			{
				match(LITERAL_PointSize);
				break;
			}
			case LITERAL_PolygonIntersections:
			{
				match(LITERAL_PolygonIntersections);
				break;
			}
			case 128:
			{
				match(128);
				break;
			}
			case LITERAL_PopupWindow:
			{
				match(LITERAL_PopupWindow);
				break;
			}
			case LITERAL_PreserveImageOptions:
			{
				match(LITERAL_PreserveImageOptions);
				break;
			}
			case LITERAL_RenderAll:
			{
				match(LITERAL_RenderAll);
				break;
			}
			case LITERAL_RotationAction:
			{
				match(LITERAL_RotationAction);
				break;
			}
			case LITERAL_SphericalRegion:
			{
				match(LITERAL_SphericalRegion);
				break;
			}
			case LITERAL_Shading:
			{
				match(LITERAL_Shading);
				break;
			}
			case LITERAL_Spec:
			{
				match(LITERAL_Spec);
				break;
			}
			case LITERAL_Specularity:
			{
				match(LITERAL_Specularity);
				break;
			}
			case LITERAL_StatusArea:
			{
				match(LITERAL_StatusArea);
				break;
			}
			case LITERAL_Style:
			{
				match(LITERAL_Style);
				break;
			}
			case LITERAL_Ticks:
			{
				match(LITERAL_Ticks);
				break;
			}
			case LITERAL_TicksStyle:
			{
				match(LITERAL_TicksStyle);
				break;
			}
			case LITERAL_Tooltip:
			{
				match(LITERAL_Tooltip);
				break;
			}
			case LITERAL_TextStyle:
			{
				match(LITERAL_TextStyle);
				break;
			}
			case LITERAL_Thickness:
			{
				match(LITERAL_Thickness);
				break;
			}
			case LITERAL_ViewPoint:
			{
				match(LITERAL_ViewPoint);
				break;
			}
			case LITERAL_ViewAngle:
			{
				match(LITERAL_ViewAngle);
				break;
			}
			case LITERAL_ViewCenter:
			{
				match(LITERAL_ViewCenter);
				break;
			}
			case LITERAL_ViewMatrix:
			{
				match(LITERAL_ViewMatrix);
				break;
			}
			case LITERAL_ViewRange:
			{
				match(LITERAL_ViewRange);
				break;
			}
			case LITERAL_ViewVector:
			{
				match(LITERAL_ViewVector);
				break;
			}
			case LITERAL_None:
			{
				match(LITERAL_None);
				break;
			}
			default:
				if ((LA(1)==LITERAL_DisplayFunction) && (_tokenSet_3.member(LA(2))) && (_tokenSet_4.member(LA(3)))) {
					match(LITERAL_DisplayFunction);
				}
				else if ((LA(1)==LITERAL_DisplayFunction) && (_tokenSet_3.member(LA(2))) && (_tokenSet_4.member(LA(3)))) {
					match(LITERAL_DisplayFunction);
				}
				else if ((LA(1)==LITERAL_ViewVertical) && (_tokenSet_3.member(LA(2))) && (_tokenSet_4.member(LA(3)))) {
					match(LITERAL_ViewVertical);
				}
				else if ((LA(1)==LITERAL_ViewVertical) && (_tokenSet_3.member(LA(2))) && (_tokenSet_4.member(LA(3)))) {
					match(LITERAL_ViewVertical);
				}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			egal();
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void indexedPointSet(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		
		System.out.println("indexedPointSet");
		// eine Abfolge von Punkten wird zu einer PointSet
		int[] points= null; 
		Integer n;
		ArrayList<Color> colList= new ArrayList<Color>();
		ArrayList<double[]> normList= new ArrayList<double[]>();
		
		
		try {      // for error handling
			match(LITERAL_Point);
			match(OPEN_BRACKET);
			{
			switch ( LA(1)) {
			case MINUS:
			case PLUS:
			case INTEGER_THING:
			{
				n=indexVektor();
				points= new int[]{n};
				break;
			}
			case OPEN_BRACE:
			{
				points=vertexIndexList();
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			{
			_loop58:
			do {
				if ((LA(1)==COLON)) {
					match(COLON);
					gcOptInside(colList,normList);
				}
				else {
					break _loop58;
				}
				
			} while (true);
			}
			match(CLOSE_BRACKET);
			
					PointSetFactory psf = new PointSetFactory();
					double [][] coords = state.getIndexCoords(points);
					psf.setVertexCount(points.length);
					psf.setVertexCoordinates(coords);
					psf.update();
					SceneGraphComponent geo=new SceneGraphComponent();
					geo.setAppearance(state.getPointSetApp());
					PointSet p=psf.getPointSet();
					state.assignColorList(p,colList);	
					state.assignNormalList(p,normList);		
					geo.setGeometry(p);
					geo.setName("indexedPoints");
					current.addChild(geo);
				
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void indexedLineSet(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		
		System.out.println("indexedLineSet");
		List<int[]> indis=new LinkedList<int[]>();
		int[] line= null;
		ArrayList<Color> colList= new ArrayList<Color>();
		ArrayList<double[]> normList= new ArrayList<double[]>();
		
		
		try {      // for error handling
			{
			switch ( LA(1)) {
			case LITERAL_Line:
			{
				match(LITERAL_Line);
				break;
			}
			case LITERAL_Tube:
			{
				match(LITERAL_Tube);
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(OPEN_BRACKET);
			{
			if ((LA(1)==OPEN_BRACE) && (LA(2)==MINUS||LA(2)==PLUS||LA(2)==INTEGER_THING)) {
				line=vertexIndexList();
				indis.add(line);
			}
			else if ((LA(1)==OPEN_BRACE) && (LA(2)==OPEN_BRACE)) {
				match(OPEN_BRACE);
				line=vertexIndexList();
				indis.add(line);
				{
				_loop69:
				do {
					if ((LA(1)==COLON)) {
						match(COLON);
						line=vertexIndexList();
						indis.add(line);
					}
					else {
						break _loop69;
					}
					
				} while (true);
				}
				match(CLOSE_BRACE);
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			
			}
			{
			_loop71:
			do {
				if ((LA(1)==COLON)) {
					match(COLON);
					gcOptInside(colList,normList);
				}
				else {
					break _loop71;
				}
				
			} while (true);
			}
			match(CLOSE_BRACKET);
			
					IndexedLineSetFactory lineset=new IndexedLineSetFactory();
					int[][] indices= new int[indis.size()][];
					for(int i=0;i<indis.size();i++)
						indices[i]=indis.get(i);
					double[][] coords= state.coords;
					lineset.setVertexCount(coords.length);
					lineset.setVertexCoordinates(coords);
					lineset.setEdgeCount(indices.length);
					lineset.setEdgeIndices(indices);
					lineset.update();
					SceneGraphComponent geo=new SceneGraphComponent();
					geo.setAppearance(state.getLineSetApp());
					IndexedLineSet ils=lineset.getIndexedLineSet();
					state.assignColorList(ils,colList);	
					state.assignNormalList(ils,normList);		
					geo.setGeometry(ils);
					geo.setName("indexedLines");
					current.addChild(geo); 
				
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void indexedFaceSet(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		
		System.out.println("indexedFaceSet");
		List<int[]> indis=new LinkedList<int[]>();
		int[] face=null;
		ArrayList<Color> colList= new ArrayList<Color>();
		ArrayList<double[]> normList= new ArrayList<double[]>();
		
		
		try {      // for error handling
			match(LITERAL_Polygon);
			match(OPEN_BRACKET);
			{
			if ((LA(1)==OPEN_BRACE) && (LA(2)==MINUS||LA(2)==PLUS||LA(2)==INTEGER_THING)) {
				face=vertexIndexList();
				indis.add(face);
			}
			else if ((LA(1)==OPEN_BRACE) && (LA(2)==OPEN_BRACE)) {
				match(OPEN_BRACE);
				face=vertexIndexList();
				indis.add(face);
				{
				_loop80:
				do {
					if ((LA(1)==COLON)) {
						match(COLON);
						face=vertexIndexList();
						indis.add(face);
					}
					else {
						break _loop80;
					}
					
				} while (true);
				}
				match(CLOSE_BRACE);
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			
			}
			{
			_loop82:
			do {
				if ((LA(1)==COLON)) {
					match(COLON);
					gcOptInside(colList,normList);
				}
				else {
					break _loop82;
				}
				
			} while (true);
			}
			match(CLOSE_BRACKET);
			
					IndexedFaceSetFactory faceSet = new IndexedFaceSetFactory();
					int[][] indices= new int[indis.size()][];
					for(int i=0;i<indis.size();i++)
						indices[i]=indis.get(i);
					double[][] coords= state.coords;
					faceSet.setVertexCount(coords.length);
					faceSet.setVertexCoordinates(coords);
					faceSet.setFaceCount(indices.length);
					faceSet.setFaceIndices(indices);
					faceSet.setGenerateFaceNormals(true);
					faceSet.update();
					IndexedFaceSet ifs= faceSet.getIndexedFaceSet();
					SceneGraphComponent geo=new SceneGraphComponent();	// Komponenten erstellen und einhaengen
					geo.setAppearance(state.getFaceApp());
					current.addChild(geo);
					geo.setName("indexedFaces");
					state.assignColorList(ifs,colList);	
					state.assignNormalList(ifs,normList);		
					geo.setGeometry(ifs);
					state.faces.add(ifs);
				
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void gcOpt(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		
		double[] n=null;
		Color c=null;
		ArrayList<Color> colList= new ArrayList<Color>();
		ArrayList<double[]> normList= new ArrayList<double[]>();
		System.out.println("gcOpt");
		
		
		try {      // for error handling
			switch ( LA(1)) {
			case LITERAL_ContentSelectable:
			{
				match(LITERAL_ContentSelectable);
				match(MINUS);
				match(LARGER);
				egal();
				break;
			}
			case LITERAL_VertexColors:
			{
				match(LITERAL_VertexColors);
				match(MINUS);
				match(LARGER);
				{
				switch ( LA(1)) {
				case LITERAL_None:
				{
					match(LITERAL_None);
					break;
				}
				case OPEN_BRACE:
				{
					match(OPEN_BRACE);
					c=vertexColor();
					colList.add(c);
					{
					_loop133:
					do {
						if ((LA(1)==COLON)) {
							match(COLON);
							c=vertexColor();
							colList.add(c);
						}
						else {
							break _loop133;
						}
						
					} while (true);
					}
					match(CLOSE_BRACE);
						  state.assignColorList(colList);	
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				break;
			}
			case LITERAL_VertexNormals:
			{
				match(LITERAL_VertexNormals);
				match(MINUS);
				match(LARGER);
				{
				switch ( LA(1)) {
				case LITERAL_None:
				{
					match(LITERAL_None);
					break;
				}
				case OPEN_BRACE:
				{
					match(OPEN_BRACE);
					n=vektor();
					normList.add(n);
					{
					_loop136:
					do {
						if ((LA(1)==COLON)) {
							match(COLON);
							n=vektor();
							normList.add(n);
						}
						else {
							break _loop136;
						}
						
					} while (true);
					}
					match(CLOSE_BRACE);
					state.assignNormalList(normList);	
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final double[]  vektor() throws RecognitionException, TokenStreamException {
		double[] res;
		
		//System.out.println("vektor");
		// ein KoordinatenTripel(Punkt) zu double[3]
		res =new double [3];
		double res1,res2,res3;
		
		
		try {      // for error handling
			match(OPEN_BRACE);
			res1=doublething();
			match(COLON);
			res2=doublething();
			match(COLON);
			res3=doublething();
			res[0]=res1;   res[1]=res2;    res[2]=res3;	
			match(CLOSE_BRACE);
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
		return res;
	}
	
	private final double  doublething() throws RecognitionException, TokenStreamException {
		double d=0;
		
		
		double a=0;
		double b=1;
		
		
		try {      // for error handling
			a=doubleHelp();
			{
			switch ( LA(1)) {
			case SLASH:
			{
				match(SLASH);
				b=doubleHelp();
				break;
			}
			case CLOSE_BRACE:
			case COLON:
			case CLOSE_BRACKET:
			case MINUS:
			case PLUS:
			case INTEGER_THING:
			case DOT:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			{
			switch ( LA(1)) {
			case MINUS:
			case PLUS:
			case INTEGER_THING:
			case DOT:
			{
				doubleHelp();
				match(STAR);
				match(LITERAL_I);
				break;
			}
			case CLOSE_BRACE:
			case COLON:
			case CLOSE_BRACKET:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			d=a/b;
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
		return d;
	}
	
	private final Integer  indexVektor() throws RecognitionException, TokenStreamException {
		Integer in;
		
		//System.out.println("indexVektor");
		int n;
		in=null;
		
		
		try {      // for error handling
			n=integerthing();
			in= new Integer(n-1);
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
		return in;
	}
	
	private final double[]  vektordata2D() throws RecognitionException, TokenStreamException {
		double[] res;
		
		//System.out.println("vektordata2D");
		// das gleiche wie vektor, beeinflusst aber nicht die Borderberechnung(Scenengroese)
		res =new double [2];
		double res1,res2;
		
		try {      // for error handling
			match(OPEN_BRACE);
			res1=doublething();
			match(COLON);
			res2=doublething();
			match(CLOSE_BRACE);
			
						 res[0]=res1;
						 res[1]=res2;
						
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_16);
		}
		return res;
	}
	
	private final double[][]  vertexList() throws RecognitionException, TokenStreamException {
		double[][] v;
		
		//System.out.println("vertexList");
		// Koordinaten in einer Liste zu Vector(double[3])
		double [] point =new double[3];
		LinkedList<double[]> verts=new LinkedList<double[]>();
		v=null;
		
		
		try {      // for error handling
			match(OPEN_BRACE);
			point=vektor();
			
					    	verts.add(point); 
					    	point =new double[3];
					
			{
			_loop109:
			do {
				if ((LA(1)==COLON)) {
					match(COLON);
					point=vektor();
					
							    	verts.add(point);
							    	point =new double[3];
							
				}
				else {
					break _loop109;
				}
				
			} while (true);
			}
			match(CLOSE_BRACE);
			
					 	v= new double[verts.size()][];
					 	int i=0;
					 	for(double[] vert:verts){
					 		v[i]=vert;
					 		i++;
					 	}
					
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
		return v;
	}
	
	private final int[]  vertexIndexList() throws RecognitionException, TokenStreamException {
		int[] v;
		
		//System.out.println("vertexindexList");
		// Koordinaten in einer Liste zu Vector(double[3])
		Integer point=null;
		LinkedList<Integer> verts=new LinkedList<Integer>();
		v=null;
		
		
		try {      // for error handling
			match(OPEN_BRACE);
			point=indexVektor();
				verts.add(point);
			{
			_loop106:
			do {
				if ((LA(1)==COLON)) {
					match(COLON);
					point=indexVektor();
						verts.add(point);
				}
				else {
					break _loop106;
				}
				
			} while (true);
			}
			match(CLOSE_BRACE);
			
					 	v= new int[verts.size()];
					 	int i=0;
					 	for(int vert:verts){
					 		v[i]=vert;
					 		i++;
					 	}
					
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
		return v;
	}
	
	private final void gcOptInside(
		ArrayList<Color> colList,ArrayList<double[]> normList
	) throws RecognitionException, TokenStreamException {
		
		
		double[] n=null;
		Color c=null;
		System.out.println("gcOptInside");
		
		
		try {      // for error handling
			switch ( LA(1)) {
			case LITERAL_ContentSelectable:
			{
				match(LITERAL_ContentSelectable);
				match(MINUS);
				match(LARGER);
				egal();
				break;
			}
			case LITERAL_VertexColors:
			{
				match(LITERAL_VertexColors);
				match(MINUS);
				match(LARGER);
				{
				switch ( LA(1)) {
				case LITERAL_None:
				{
					match(LITERAL_None);
					break;
				}
				case OPEN_BRACE:
				{
					match(OPEN_BRACE);
					c=vertexColor();
					colList.add(c);
					{
					_loop140:
					do {
						if ((LA(1)==COLON)) {
							match(COLON);
							c=vertexColor();
							colList.add(c);
						}
						else {
							break _loop140;
						}
						
					} while (true);
					}
					match(CLOSE_BRACE);
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				break;
			}
			case LITERAL_VertexNormals:
			{
				match(LITERAL_VertexNormals);
				match(MINUS);
				match(LARGER);
				{
				switch ( LA(1)) {
				case LITERAL_None:
				{
					match(LITERAL_None);
					break;
				}
				case OPEN_BRACE:
				{
					match(OPEN_BRACE);
					n=vektor();
					normList.add(n);
					{
					_loop143:
					do {
						if ((LA(1)==COLON)) {
							match(COLON);
							n=vektor();
							normList.add(n);
						}
						else {
							break _loop143;
						}
						
					} while (true);
					}
					match(CLOSE_BRACE);
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_16);
		}
	}
	
	private final Color  faceColor(
		MState state
	) throws RecognitionException, TokenStreamException {
		Color fC;
		
		
		System.out.println("faceColor");
		// Farben fuer Flaechen sind in 'SurfaceColor[]' gekapselt
		Color specular; double d; fC= new Color(255,0,0);
		
		
		try {      // for error handling
			match(LITERAL_SurfaceColor);
			match(OPEN_BRACKET);
			fC=color(state);
			state.faceColor=fC;
			{
			if ((_tokenSet_17.member(LA(1))) && ((LA(2) >= OPEN_BRACE && LA(2) <= WS_)) && (_tokenSet_4.member(LA(3)))) {
				waste();
			}
			else if ((LA(1)==CLOSE_BRACKET) && (_tokenSet_3.member(LA(2))) && (_tokenSet_4.member(LA(3)))) {
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			
			}
			match(CLOSE_BRACKET);
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_3);
		}
		return fC;
	}
	
	private final Color  color(
		MState state
	) throws RecognitionException, TokenStreamException {
		Color c;
		
		
		System.out.println("color");
		// liest eine Farbe 
		// Farben haben verschiedene Darstellungen
		c= new Color(0,255,0);
		
		try {      // for error handling
			switch ( LA(1)) {
			case LITERAL_Red:
			{
				match(LITERAL_Red);
				c=MHelper.rgbaToRgba(1,0,0,1);
				break;
			}
			case LITERAL_Green:
			{
				match(LITERAL_Green);
				c=MHelper.rgbaToRgba(0,1,0,1);
				break;
			}
			case LITERAL_Blue:
			{
				match(LITERAL_Blue);
				c=MHelper.rgbaToRgba(0,0,1,1);
				break;
			}
			case LITERAL_Black:
			{
				match(LITERAL_Black);
				c=MHelper.rgbaToRgba(0,0,0,1);
				break;
			}
			case LITERAL_White:
			{
				match(LITERAL_White);
				c=MHelper.rgbaToRgba(1,1,1,1);
				break;
			}
			case LITERAL_Gray:
			{
				match(LITERAL_Gray);
				c=MHelper.rgbaToRgba(.5,.5,.5,1);
				break;
			}
			case LITERAL_Cyan:
			{
				match(LITERAL_Cyan);
				c=MHelper.rgbaToRgba(0,1,1,1);
				break;
			}
			case LITERAL_Magenta:
			{
				match(LITERAL_Magenta);
				c=MHelper.rgbaToRgba(1,0,1,1);
				break;
			}
			case LITERAL_Yellow:
			{
				match(LITERAL_Yellow);
				c=MHelper.rgbaToRgba(1,1,0,1);
				break;
			}
			case LITERAL_Brown:
			{
				match(LITERAL_Brown);
				c=MHelper.rgbaToRgba(0.6,0.4,0.2,1);
				break;
			}
			case LITERAL_Orange:
			{
				match(LITERAL_Orange);
				c=MHelper.rgbaToRgba(1,.5,0,1);
				break;
			}
			case LITERAL_Pink:
			{
				match(LITERAL_Pink);
				c=MHelper.rgbaToRgba(1,.5,.5,1);
				break;
			}
			case LITERAL_Purple:
			{
				match(LITERAL_Purple);
				c=MHelper.rgbaToRgba(.5,0,.5,1);
				break;
			}
			case LITERAL_LightRed:
			{
				match(LITERAL_LightRed);
				c=MHelper.lighter(MHelper.rgbaToRgba(1,0,0,1),.85);
				break;
			}
			case LITERAL_LightGreen:
			{
				match(LITERAL_LightGreen);
				c=MHelper.lighter(MHelper.rgbaToRgba(0,1,0,1),.88);
				break;
			}
			case LITERAL_LightBlue:
			{
				match(LITERAL_LightBlue);
				c=MHelper.rgbaToRgba(0.87,0.94,1,1);
				break;
			}
			case LITERAL_LightGray:
			{
				match(LITERAL_LightGray);
				c=MHelper.lighter(MHelper.rgbaToRgba(.5,.5,.5,1),.70);
				break;
			}
			case LITERAL_LightCyan:
			{
				match(LITERAL_LightCyan);
				c=MHelper.lighter(MHelper.rgbaToRgba(0,1,1,1),.90);
				break;
			}
			case LITERAL_LightMagenta:
			{
				match(LITERAL_LightMagenta);
				c=MHelper.lighter(MHelper.rgbaToRgba(1,0,1,1),.90);
				break;
			}
			case LITERAL_LightYellow:
			{
				match(LITERAL_LightYellow);
				c=MHelper.lighter(MHelper.rgbaToRgba(.85,.85,0,1),.85);
				break;
			}
			case LITERAL_LightBrown:
			{
				match(LITERAL_LightBrown);
				c=MHelper.lighter(MHelper.rgbaToRgba(0.6,0.4,0.2,1),.85);
				break;
			}
			case LITERAL_LightOrange:
			{
				match(LITERAL_LightOrange);
				c=MHelper.rgbaToRgba(1,0.9,0.75,1);
				break;
			}
			case LITERAL_LightPink:
			{
				match(LITERAL_LightPink);
				c=MHelper.lighter(MHelper.rgbaToRgba(1,.5,.5,1),.85);
				break;
			}
			case LITERAL_LightPurple:
			{
				match(LITERAL_LightPurple);
				c=MHelper.lighter(MHelper.rgbaToRgba(.5,0,.5,1),.88);
				break;
			}
			case LITERAL_Lighter:
			{
				match(LITERAL_Lighter);
				match(OPEN_BRACKET);
				double frac=1./3;
				c=color(state);
				{
				switch ( LA(1)) {
				case COLON:
				{
					match(COLON);
					frac=doublething();
					break;
				}
				case CLOSE_BRACKET:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				match(CLOSE_BRACKET);
				
									c=MHelper.lighter(c,frac);
									
				break;
			}
			case LITERAL_Darker:
			{
				match(LITERAL_Darker);
				match(OPEN_BRACKET);
				double frac=1./3;
				c=color(state);
				{
				switch ( LA(1)) {
				case COLON:
				{
					match(COLON);
					frac=doublething();
					break;
				}
				case CLOSE_BRACKET:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				match(CLOSE_BRACKET);
				
									c=MHelper.darker(c,frac);
									
				break;
			}
			case LITERAL_RGBColor:
			{
				match(LITERAL_RGBColor);
				match(OPEN_BRACKET);
				double r,g,b,a; r=b=g=0; a=1;
				{
				switch ( LA(1)) {
				case OPEN_BRACE:
				{
					match(OPEN_BRACE);
					r=doublething();
					match(COLON);
					g=doublething();
					match(COLON);
					b=doublething();
					match(CLOSE_BRACE);
					break;
				}
				case MINUS:
				case PLUS:
				case INTEGER_THING:
				case DOT:
				{
					r=doublething();
					match(COLON);
					g=doublething();
					match(COLON);
					b=doublething();
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				match(CLOSE_BRACKET);
				
									 c=MHelper.rgbaToRgba(r,g,b,a);
									 state.setColor(c);
								 	
				break;
			}
			case LITERAL_Hue:
			{
				match(LITERAL_Hue);
				match(OPEN_BRACKET);
				double h=.5; double s=1;	double b=1;	double a=0;
				{
				switch ( LA(1)) {
				case OPEN_BRACE:
				{
					match(OPEN_BRACE);
					break;
				}
				case MINUS:
				case PLUS:
				case INTEGER_THING:
				case DOT:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				h=doublething();
				{
				switch ( LA(1)) {
				case COLON:
				{
					match(COLON);
					s=doublething();
					match(COLON);
					b=doublething();
					{
					switch ( LA(1)) {
					case COLON:
					{
						match(COLON);
						a=doublething();
						break;
					}
					case CLOSE_BRACE:
					case CLOSE_BRACKET:
					{
						break;
					}
					default:
					{
						throw new NoViableAltException(LT(1), getFilename());
					}
					}
					}
					break;
				}
				case CLOSE_BRACE:
				case CLOSE_BRACKET:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				{
				switch ( LA(1)) {
				case CLOSE_BRACE:
				{
					match(CLOSE_BRACE);
					break;
				}
				case CLOSE_BRACKET:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				match(CLOSE_BRACKET);
				
									 c = MHelper.hsbaToRgba(h,s,b,a);
									 state.setColor(c);
									
				break;
			}
			case LITERAL_GrayLevel:
			{
				match(LITERAL_GrayLevel);
				match(OPEN_BRACKET);
				double gr=0; double a=1;
				gr=doublething();
				{
				switch ( LA(1)) {
				case COLON:
				{
					match(COLON);
					a=doublething();
					break;
				}
				case CLOSE_BRACKET:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				match(CLOSE_BRACKET);
				
										c=MHelper.greyLevelToRgba(gr,a);
										state.setColor(c);
									
				break;
			}
			case LITERAL_CMYKColor:
			{
				match(LITERAL_CMYKColor);
				match(OPEN_BRACKET);
				
									 double cy,ma,ye,k; 
									 cy=ma=ye=k=0; 
									 double a=1;
									
				{
				switch ( LA(1)) {
				case OPEN_BRACE:
				{
					match(OPEN_BRACE);
					break;
				}
				case MINUS:
				case PLUS:
				case INTEGER_THING:
				case DOT:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				cy=doublething();
				match(COLON);
				ma=doublething();
				match(COLON);
				ye=doublething();
				match(COLON);
				k=doublething();
				{
				switch ( LA(1)) {
				case COLON:
				{
					match(COLON);
					a=doublething();
					break;
				}
				case CLOSE_BRACE:
				case CLOSE_BRACKET:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				{
				switch ( LA(1)) {
				case CLOSE_BRACE:
				{
					match(CLOSE_BRACE);
					break;
				}
				case CLOSE_BRACKET:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				match(CLOSE_BRACKET);
				
									c=MHelper.cmykaToRgba(cy,ma,ye,k,a);
									state.setColor(c);
									
				break;
			}
			case LITERAL_Opacity:
			{
				match(LITERAL_Opacity);
				match(OPEN_BRACKET);
				c=state.color; double o=0;
				o=doublething();
				{
				switch ( LA(1)) {
				case COLON:
				{
					match(COLON);
					c=color(state);
					break;
				}
				case CLOSE_BRACKET:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				match(CLOSE_BRACKET);
				
									c=MHelper.opacity(c,o);
									state.setColor(c);
									
				break;
			}
			case LITERAL_Directive:
			{
				c=directiveComplex(state);
				break;
			}
			case LITERAL_SurfaceColor:
			{
				c=faceColor(state);
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_3);
		}
		return c;
	}
	
	private final Color  directiveComplex(
		MState state
	) throws RecognitionException, TokenStreamException {
		Color c;
		
		
		System.out.println("color");
		c= new Color(0,255,0);
		
		
		try {      // for error handling
			match(LITERAL_Directive);
			match(OPEN_BRACKET);
			dirList(state);
			match(CLOSE_BRACKET);
			
				   c=state.getColor();
				
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_3);
		}
		return c;
	}
	
	private final void dirList(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		
		try {      // for error handling
			{
			switch ( LA(1)) {
			case LITERAL_SurfaceColor:
			case LITERAL_Red:
			case LITERAL_Green:
			case LITERAL_Blue:
			case LITERAL_Black:
			case LITERAL_White:
			case LITERAL_Gray:
			case LITERAL_Cyan:
			case LITERAL_Magenta:
			case LITERAL_Yellow:
			case LITERAL_Brown:
			case LITERAL_Orange:
			case LITERAL_Pink:
			case LITERAL_Purple:
			case LITERAL_LightRed:
			case LITERAL_LightGreen:
			case LITERAL_LightBlue:
			case LITERAL_LightGray:
			case LITERAL_LightCyan:
			case LITERAL_LightMagenta:
			case LITERAL_LightYellow:
			case LITERAL_LightBrown:
			case LITERAL_LightOrange:
			case LITERAL_LightPink:
			case LITERAL_LightPurple:
			case LITERAL_Lighter:
			case LITERAL_Darker:
			case LITERAL_RGBColor:
			case LITERAL_Hue:
			case LITERAL_GrayLevel:
			case LITERAL_CMYKColor:
			case LITERAL_Opacity:
			case LITERAL_Directive:
			case LITERAL_EdgeForm:
			case LITERAL_FaceForm:
			case LITERAL_ContentSelectable:
			case LITERAL_None:
			case LITERAL_Arrow:
			case LITERAL_AbsoluteDashing:
			case LITERAL_AbsolutePointSize:
			case LITERAL_AbsoluteThickness:
			case LITERAL_Arrowheads:
			case LITERAL_Annotation:
			case LITERAL_AlignmentPoint:
			case LITERAL_AspectRatio:
			case LITERAL_Axes:
			case LITERAL_AxesEdge:
			case LITERAL_AxesLabel:
			case LITERAL_AxesOrigin:
			case LITERAL_AxesStyle:
			case LITERAL_AmbientLight:
			case LITERAL_BezierCurve:
			case LITERAL_BSplineCurve:
			case LITERAL_BSplineSurface:
			case LITERAL_Button:
			case LITERAL_Background:
			case LITERAL_BaselinePosition:
			case LITERAL_BaseStyle:
			case LITERAL_Boxed:
			case LITERAL_BoxRatios:
			case LITERAL_BoxStyle:
			case LITERAL_CapForm:
			case LITERAL_ControllerLinking:
			case LITERAL_ControllerMethod:
			case LITERAL_ControllerPath:
			case LITERAL_ColorOutput:
			case LITERAL_Dashing:
			case LITERAL_Dynamic:
			case LITERAL_DisplayFunction:
			case LITERAL_DefaultColor:
			case LITERAL_DefaultFont:
			case LITERAL_Epilog:
			case LITERAL_EventHandler:
			case LITERAL_FaceGrids:
			case LITERAL_FaceGridsStyle:
			case LITERAL_FormatType:
			case LITERAL_Hyperlink:
			case LITERAL_ImageMargins:
			case LITERAL_ImagePadding:
			case LITERAL_ImageSize:
			case LITERAL_JoinForm:
			case LITERAL_Lighting:
			case LITERAL_LightSources:
			case LITERAL_LabelStyle:
			case LITERAL_Mouseover:
			case LITERAL_Method:
			case LITERAL_Prolog:
			case LITERAL_PlotRange:
			case LITERAL_PlotRangePadding:
			case LITERAL_PlotLabel:
			case LITERAL_PlotRegion:
			case LITERAL_PointSize:
			case LITERAL_PolygonIntersections:
			case 128:
			case LITERAL_PopupWindow:
			case LITERAL_PreserveImageOptions:
			case LITERAL_RenderAll:
			case LITERAL_RotationAction:
			case LITERAL_SphericalRegion:
			case LITERAL_Shading:
			case LITERAL_Spec:
			case LITERAL_Specularity:
			case LITERAL_StatusArea:
			case LITERAL_Style:
			case LITERAL_Ticks:
			case LITERAL_TicksStyle:
			case LITERAL_Tooltip:
			case LITERAL_TextStyle:
			case LITERAL_Thickness:
			case LITERAL_ViewPoint:
			case LITERAL_ViewAngle:
			case LITERAL_ViewCenter:
			case LITERAL_ViewVertical:
			case LITERAL_ViewMatrix:
			case LITERAL_ViewRange:
			case LITERAL_ViewVector:
			{
				directive(state);
				break;
			}
			case OPEN_BRACE:
			{
				match(OPEN_BRACE);
				dirList(state);
				match(CLOSE_BRACE);
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			{
			_loop103:
			do {
				if ((LA(1)==COLON)) {
					match(COLON);
					{
					switch ( LA(1)) {
					case LITERAL_SurfaceColor:
					case LITERAL_Red:
					case LITERAL_Green:
					case LITERAL_Blue:
					case LITERAL_Black:
					case LITERAL_White:
					case LITERAL_Gray:
					case LITERAL_Cyan:
					case LITERAL_Magenta:
					case LITERAL_Yellow:
					case LITERAL_Brown:
					case LITERAL_Orange:
					case LITERAL_Pink:
					case LITERAL_Purple:
					case LITERAL_LightRed:
					case LITERAL_LightGreen:
					case LITERAL_LightBlue:
					case LITERAL_LightGray:
					case LITERAL_LightCyan:
					case LITERAL_LightMagenta:
					case LITERAL_LightYellow:
					case LITERAL_LightBrown:
					case LITERAL_LightOrange:
					case LITERAL_LightPink:
					case LITERAL_LightPurple:
					case LITERAL_Lighter:
					case LITERAL_Darker:
					case LITERAL_RGBColor:
					case LITERAL_Hue:
					case LITERAL_GrayLevel:
					case LITERAL_CMYKColor:
					case LITERAL_Opacity:
					case LITERAL_Directive:
					case LITERAL_EdgeForm:
					case LITERAL_FaceForm:
					case LITERAL_ContentSelectable:
					case LITERAL_None:
					case LITERAL_Arrow:
					case LITERAL_AbsoluteDashing:
					case LITERAL_AbsolutePointSize:
					case LITERAL_AbsoluteThickness:
					case LITERAL_Arrowheads:
					case LITERAL_Annotation:
					case LITERAL_AlignmentPoint:
					case LITERAL_AspectRatio:
					case LITERAL_Axes:
					case LITERAL_AxesEdge:
					case LITERAL_AxesLabel:
					case LITERAL_AxesOrigin:
					case LITERAL_AxesStyle:
					case LITERAL_AmbientLight:
					case LITERAL_BezierCurve:
					case LITERAL_BSplineCurve:
					case LITERAL_BSplineSurface:
					case LITERAL_Button:
					case LITERAL_Background:
					case LITERAL_BaselinePosition:
					case LITERAL_BaseStyle:
					case LITERAL_Boxed:
					case LITERAL_BoxRatios:
					case LITERAL_BoxStyle:
					case LITERAL_CapForm:
					case LITERAL_ControllerLinking:
					case LITERAL_ControllerMethod:
					case LITERAL_ControllerPath:
					case LITERAL_ColorOutput:
					case LITERAL_Dashing:
					case LITERAL_Dynamic:
					case LITERAL_DisplayFunction:
					case LITERAL_DefaultColor:
					case LITERAL_DefaultFont:
					case LITERAL_Epilog:
					case LITERAL_EventHandler:
					case LITERAL_FaceGrids:
					case LITERAL_FaceGridsStyle:
					case LITERAL_FormatType:
					case LITERAL_Hyperlink:
					case LITERAL_ImageMargins:
					case LITERAL_ImagePadding:
					case LITERAL_ImageSize:
					case LITERAL_JoinForm:
					case LITERAL_Lighting:
					case LITERAL_LightSources:
					case LITERAL_LabelStyle:
					case LITERAL_Mouseover:
					case LITERAL_Method:
					case LITERAL_Prolog:
					case LITERAL_PlotRange:
					case LITERAL_PlotRangePadding:
					case LITERAL_PlotLabel:
					case LITERAL_PlotRegion:
					case LITERAL_PointSize:
					case LITERAL_PolygonIntersections:
					case 128:
					case LITERAL_PopupWindow:
					case LITERAL_PreserveImageOptions:
					case LITERAL_RenderAll:
					case LITERAL_RotationAction:
					case LITERAL_SphericalRegion:
					case LITERAL_Shading:
					case LITERAL_Spec:
					case LITERAL_Specularity:
					case LITERAL_StatusArea:
					case LITERAL_Style:
					case LITERAL_Ticks:
					case LITERAL_TicksStyle:
					case LITERAL_Tooltip:
					case LITERAL_TextStyle:
					case LITERAL_Thickness:
					case LITERAL_ViewPoint:
					case LITERAL_ViewAngle:
					case LITERAL_ViewCenter:
					case LITERAL_ViewVertical:
					case LITERAL_ViewMatrix:
					case LITERAL_ViewRange:
					case LITERAL_ViewVector:
					{
						directive(state);
						break;
					}
					case OPEN_BRACE:
					{
						match(OPEN_BRACE);
						dirList(state);
						match(CLOSE_BRACE);
						break;
					}
					default:
					{
						throw new NoViableAltException(LT(1), getFilename());
					}
					}
					}
				}
				else {
					break _loop103;
				}
				
			} while (true);
			}
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_7);
		}
	}
	
	private final int  integerthing() throws RecognitionException, TokenStreamException {
		int i;
		
		Token  s = null;
		i=0;String sig="";
		
		try {      // for error handling
			{
			switch ( LA(1)) {
			case PLUS:
			{
				match(PLUS);
				break;
			}
			case MINUS:
			{
				match(MINUS);
				sig="-";
				break;
			}
			case INTEGER_THING:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			s = LT(1);
			match(INTEGER_THING);
			i=Integer.parseInt(sig + s.getText());
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
		return i;
	}
	
	private final void edgeForm(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		state.edgeDraw=false;
		
		try {      // for error handling
			match(LITERAL_EdgeForm);
			match(OPEN_BRACKET);
			{
			switch ( LA(1)) {
			case OPEN_BRACE:
			case LITERAL_SurfaceColor:
			case LITERAL_Red:
			case LITERAL_Green:
			case LITERAL_Blue:
			case LITERAL_Black:
			case LITERAL_White:
			case LITERAL_Gray:
			case LITERAL_Cyan:
			case LITERAL_Magenta:
			case LITERAL_Yellow:
			case LITERAL_Brown:
			case LITERAL_Orange:
			case LITERAL_Pink:
			case LITERAL_Purple:
			case LITERAL_LightRed:
			case LITERAL_LightGreen:
			case LITERAL_LightBlue:
			case LITERAL_LightGray:
			case LITERAL_LightCyan:
			case LITERAL_LightMagenta:
			case LITERAL_LightYellow:
			case LITERAL_LightBrown:
			case LITERAL_LightOrange:
			case LITERAL_LightPink:
			case LITERAL_LightPurple:
			case LITERAL_Lighter:
			case LITERAL_Darker:
			case LITERAL_RGBColor:
			case LITERAL_Hue:
			case LITERAL_GrayLevel:
			case LITERAL_CMYKColor:
			case LITERAL_Opacity:
			case LITERAL_Directive:
			case LITERAL_ContentSelectable:
			case LITERAL_None:
			case LITERAL_Arrow:
			case LITERAL_AbsoluteDashing:
			case LITERAL_AbsolutePointSize:
			case LITERAL_AbsoluteThickness:
			case LITERAL_Arrowheads:
			case LITERAL_Annotation:
			case LITERAL_AlignmentPoint:
			case LITERAL_AspectRatio:
			case LITERAL_Axes:
			case LITERAL_AxesEdge:
			case LITERAL_AxesLabel:
			case LITERAL_AxesOrigin:
			case LITERAL_AxesStyle:
			case LITERAL_AmbientLight:
			case LITERAL_BezierCurve:
			case LITERAL_BSplineCurve:
			case LITERAL_BSplineSurface:
			case LITERAL_Button:
			case LITERAL_Background:
			case LITERAL_BaselinePosition:
			case LITERAL_BaseStyle:
			case LITERAL_Boxed:
			case LITERAL_BoxRatios:
			case LITERAL_BoxStyle:
			case LITERAL_CapForm:
			case LITERAL_ControllerLinking:
			case LITERAL_ControllerMethod:
			case LITERAL_ControllerPath:
			case LITERAL_ColorOutput:
			case LITERAL_Dashing:
			case LITERAL_Dynamic:
			case LITERAL_DisplayFunction:
			case LITERAL_DefaultColor:
			case LITERAL_DefaultFont:
			case LITERAL_Epilog:
			case LITERAL_EventHandler:
			case LITERAL_FaceGrids:
			case LITERAL_FaceGridsStyle:
			case LITERAL_FormatType:
			case LITERAL_Hyperlink:
			case LITERAL_ImageMargins:
			case LITERAL_ImagePadding:
			case LITERAL_ImageSize:
			case LITERAL_JoinForm:
			case LITERAL_Lighting:
			case LITERAL_LightSources:
			case LITERAL_LabelStyle:
			case LITERAL_Mouseover:
			case LITERAL_Method:
			case LITERAL_Prolog:
			case LITERAL_PlotRange:
			case LITERAL_PlotRangePadding:
			case LITERAL_PlotLabel:
			case LITERAL_PlotRegion:
			case LITERAL_PointSize:
			case LITERAL_PolygonIntersections:
			case 128:
			case LITERAL_PopupWindow:
			case LITERAL_PreserveImageOptions:
			case LITERAL_RenderAll:
			case LITERAL_RotationAction:
			case LITERAL_SphericalRegion:
			case LITERAL_Shading:
			case LITERAL_Spec:
			case LITERAL_Specularity:
			case LITERAL_StatusArea:
			case LITERAL_Style:
			case LITERAL_Ticks:
			case LITERAL_TicksStyle:
			case LITERAL_Tooltip:
			case LITERAL_TextStyle:
			case LITERAL_Thickness:
			case LITERAL_ViewPoint:
			case LITERAL_ViewAngle:
			case LITERAL_ViewCenter:
			case LITERAL_ViewVertical:
			case LITERAL_ViewMatrix:
			case LITERAL_ViewRange:
			case LITERAL_ViewVector:
			{
				edgeFormContent(state);
				{
				_loop117:
				do {
					if ((LA(1)==COLON)) {
						match(COLON);
						edgeFormContent(state);
					}
					else {
						break _loop117;
					}
					
				} while (true);
				}
				state.edgeDraw=true;
				break;
			}
			case CLOSE_BRACKET:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(CLOSE_BRACKET);
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void faceForm(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		state.faceDraw=false;
		
		try {      // for error handling
			match(LITERAL_FaceForm);
			match(OPEN_BRACKET);
			{
			switch ( LA(1)) {
			case OPEN_BRACE:
			case LITERAL_SurfaceColor:
			case LITERAL_Red:
			case LITERAL_Green:
			case LITERAL_Blue:
			case LITERAL_Black:
			case LITERAL_White:
			case LITERAL_Gray:
			case LITERAL_Cyan:
			case LITERAL_Magenta:
			case LITERAL_Yellow:
			case LITERAL_Brown:
			case LITERAL_Orange:
			case LITERAL_Pink:
			case LITERAL_Purple:
			case LITERAL_LightRed:
			case LITERAL_LightGreen:
			case LITERAL_LightBlue:
			case LITERAL_LightGray:
			case LITERAL_LightCyan:
			case LITERAL_LightMagenta:
			case LITERAL_LightYellow:
			case LITERAL_LightBrown:
			case LITERAL_LightOrange:
			case LITERAL_LightPink:
			case LITERAL_LightPurple:
			case LITERAL_Lighter:
			case LITERAL_Darker:
			case LITERAL_RGBColor:
			case LITERAL_Hue:
			case LITERAL_GrayLevel:
			case LITERAL_CMYKColor:
			case LITERAL_Opacity:
			case LITERAL_Directive:
			case LITERAL_ContentSelectable:
			case LITERAL_None:
			case LITERAL_Arrow:
			case LITERAL_AbsoluteDashing:
			case LITERAL_AbsolutePointSize:
			case LITERAL_AbsoluteThickness:
			case LITERAL_Arrowheads:
			case LITERAL_Annotation:
			case LITERAL_AlignmentPoint:
			case LITERAL_AspectRatio:
			case LITERAL_Axes:
			case LITERAL_AxesEdge:
			case LITERAL_AxesLabel:
			case LITERAL_AxesOrigin:
			case LITERAL_AxesStyle:
			case LITERAL_AmbientLight:
			case LITERAL_BezierCurve:
			case LITERAL_BSplineCurve:
			case LITERAL_BSplineSurface:
			case LITERAL_Button:
			case LITERAL_Background:
			case LITERAL_BaselinePosition:
			case LITERAL_BaseStyle:
			case LITERAL_Boxed:
			case LITERAL_BoxRatios:
			case LITERAL_BoxStyle:
			case LITERAL_CapForm:
			case LITERAL_ControllerLinking:
			case LITERAL_ControllerMethod:
			case LITERAL_ControllerPath:
			case LITERAL_ColorOutput:
			case LITERAL_Dashing:
			case LITERAL_Dynamic:
			case LITERAL_DisplayFunction:
			case LITERAL_DefaultColor:
			case LITERAL_DefaultFont:
			case LITERAL_Epilog:
			case LITERAL_EventHandler:
			case LITERAL_FaceGrids:
			case LITERAL_FaceGridsStyle:
			case LITERAL_FormatType:
			case LITERAL_Hyperlink:
			case LITERAL_ImageMargins:
			case LITERAL_ImagePadding:
			case LITERAL_ImageSize:
			case LITERAL_JoinForm:
			case LITERAL_Lighting:
			case LITERAL_LightSources:
			case LITERAL_LabelStyle:
			case LITERAL_Mouseover:
			case LITERAL_Method:
			case LITERAL_Prolog:
			case LITERAL_PlotRange:
			case LITERAL_PlotRangePadding:
			case LITERAL_PlotLabel:
			case LITERAL_PlotRegion:
			case LITERAL_PointSize:
			case LITERAL_PolygonIntersections:
			case 128:
			case LITERAL_PopupWindow:
			case LITERAL_PreserveImageOptions:
			case LITERAL_RenderAll:
			case LITERAL_RotationAction:
			case LITERAL_SphericalRegion:
			case LITERAL_Shading:
			case LITERAL_Spec:
			case LITERAL_Specularity:
			case LITERAL_StatusArea:
			case LITERAL_Style:
			case LITERAL_Ticks:
			case LITERAL_TicksStyle:
			case LITERAL_Tooltip:
			case LITERAL_TextStyle:
			case LITERAL_Thickness:
			case LITERAL_ViewPoint:
			case LITERAL_ViewAngle:
			case LITERAL_ViewCenter:
			case LITERAL_ViewVertical:
			case LITERAL_ViewMatrix:
			case LITERAL_ViewRange:
			case LITERAL_ViewVector:
			{
				faceFormContent(state);
				{
				_loop125:
				do {
					if ((LA(1)==COLON)) {
						match(COLON);
						faceFormContent(state);
					}
					else {
						break _loop125;
					}
					
				} while (true);
				}
				state.faceDraw=true;
				break;
			}
			case CLOSE_BRACKET:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(CLOSE_BRACKET);
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void edgeFormContent(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		Color col;
		
		try {      // for error handling
			switch ( LA(1)) {
			case LITERAL_SurfaceColor:
			case LITERAL_Red:
			case LITERAL_Green:
			case LITERAL_Blue:
			case LITERAL_Black:
			case LITERAL_White:
			case LITERAL_Gray:
			case LITERAL_Cyan:
			case LITERAL_Magenta:
			case LITERAL_Yellow:
			case LITERAL_Brown:
			case LITERAL_Orange:
			case LITERAL_Pink:
			case LITERAL_Purple:
			case LITERAL_LightRed:
			case LITERAL_LightGreen:
			case LITERAL_LightBlue:
			case LITERAL_LightGray:
			case LITERAL_LightCyan:
			case LITERAL_LightMagenta:
			case LITERAL_LightYellow:
			case LITERAL_LightBrown:
			case LITERAL_LightOrange:
			case LITERAL_LightPink:
			case LITERAL_LightPurple:
			case LITERAL_Lighter:
			case LITERAL_Darker:
			case LITERAL_RGBColor:
			case LITERAL_Hue:
			case LITERAL_GrayLevel:
			case LITERAL_CMYKColor:
			case LITERAL_Opacity:
			case LITERAL_Directive:
			{
				col=color(state);
				state.edgeColor=col;
				break;
			}
			case OPEN_BRACE:
			{
				match(OPEN_BRACE);
				{
				switch ( LA(1)) {
				case OPEN_BRACE:
				case LITERAL_SurfaceColor:
				case LITERAL_Red:
				case LITERAL_Green:
				case LITERAL_Blue:
				case LITERAL_Black:
				case LITERAL_White:
				case LITERAL_Gray:
				case LITERAL_Cyan:
				case LITERAL_Magenta:
				case LITERAL_Yellow:
				case LITERAL_Brown:
				case LITERAL_Orange:
				case LITERAL_Pink:
				case LITERAL_Purple:
				case LITERAL_LightRed:
				case LITERAL_LightGreen:
				case LITERAL_LightBlue:
				case LITERAL_LightGray:
				case LITERAL_LightCyan:
				case LITERAL_LightMagenta:
				case LITERAL_LightYellow:
				case LITERAL_LightBrown:
				case LITERAL_LightOrange:
				case LITERAL_LightPink:
				case LITERAL_LightPurple:
				case LITERAL_Lighter:
				case LITERAL_Darker:
				case LITERAL_RGBColor:
				case LITERAL_Hue:
				case LITERAL_GrayLevel:
				case LITERAL_CMYKColor:
				case LITERAL_Opacity:
				case LITERAL_Directive:
				case LITERAL_ContentSelectable:
				case LITERAL_None:
				case LITERAL_Arrow:
				case LITERAL_AbsoluteDashing:
				case LITERAL_AbsolutePointSize:
				case LITERAL_AbsoluteThickness:
				case LITERAL_Arrowheads:
				case LITERAL_Annotation:
				case LITERAL_AlignmentPoint:
				case LITERAL_AspectRatio:
				case LITERAL_Axes:
				case LITERAL_AxesEdge:
				case LITERAL_AxesLabel:
				case LITERAL_AxesOrigin:
				case LITERAL_AxesStyle:
				case LITERAL_AmbientLight:
				case LITERAL_BezierCurve:
				case LITERAL_BSplineCurve:
				case LITERAL_BSplineSurface:
				case LITERAL_Button:
				case LITERAL_Background:
				case LITERAL_BaselinePosition:
				case LITERAL_BaseStyle:
				case LITERAL_Boxed:
				case LITERAL_BoxRatios:
				case LITERAL_BoxStyle:
				case LITERAL_CapForm:
				case LITERAL_ControllerLinking:
				case LITERAL_ControllerMethod:
				case LITERAL_ControllerPath:
				case LITERAL_ColorOutput:
				case LITERAL_Dashing:
				case LITERAL_Dynamic:
				case LITERAL_DisplayFunction:
				case LITERAL_DefaultColor:
				case LITERAL_DefaultFont:
				case LITERAL_Epilog:
				case LITERAL_EventHandler:
				case LITERAL_FaceGrids:
				case LITERAL_FaceGridsStyle:
				case LITERAL_FormatType:
				case LITERAL_Hyperlink:
				case LITERAL_ImageMargins:
				case LITERAL_ImagePadding:
				case LITERAL_ImageSize:
				case LITERAL_JoinForm:
				case LITERAL_Lighting:
				case LITERAL_LightSources:
				case LITERAL_LabelStyle:
				case LITERAL_Mouseover:
				case LITERAL_Method:
				case LITERAL_Prolog:
				case LITERAL_PlotRange:
				case LITERAL_PlotRangePadding:
				case LITERAL_PlotLabel:
				case LITERAL_PlotRegion:
				case LITERAL_PointSize:
				case LITERAL_PolygonIntersections:
				case 128:
				case LITERAL_PopupWindow:
				case LITERAL_PreserveImageOptions:
				case LITERAL_RenderAll:
				case LITERAL_RotationAction:
				case LITERAL_SphericalRegion:
				case LITERAL_Shading:
				case LITERAL_Spec:
				case LITERAL_Specularity:
				case LITERAL_StatusArea:
				case LITERAL_Style:
				case LITERAL_Ticks:
				case LITERAL_TicksStyle:
				case LITERAL_Tooltip:
				case LITERAL_TextStyle:
				case LITERAL_Thickness:
				case LITERAL_ViewPoint:
				case LITERAL_ViewAngle:
				case LITERAL_ViewCenter:
				case LITERAL_ViewVertical:
				case LITERAL_ViewMatrix:
				case LITERAL_ViewRange:
				case LITERAL_ViewVector:
				{
					edgeFormContent(state);
					{
					_loop121:
					do {
						if ((LA(1)==COLON)) {
							match(COLON);
							edgeFormContent(state);
						}
						else {
							break _loop121;
						}
						
					} while (true);
					}
					break;
				}
				case CLOSE_BRACE:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				match(CLOSE_BRACE);
				break;
			}
			case LITERAL_ContentSelectable:
			case LITERAL_None:
			case LITERAL_Arrow:
			case LITERAL_AbsoluteDashing:
			case LITERAL_AbsolutePointSize:
			case LITERAL_AbsoluteThickness:
			case LITERAL_Arrowheads:
			case LITERAL_Annotation:
			case LITERAL_AlignmentPoint:
			case LITERAL_AspectRatio:
			case LITERAL_Axes:
			case LITERAL_AxesEdge:
			case LITERAL_AxesLabel:
			case LITERAL_AxesOrigin:
			case LITERAL_AxesStyle:
			case LITERAL_AmbientLight:
			case LITERAL_BezierCurve:
			case LITERAL_BSplineCurve:
			case LITERAL_BSplineSurface:
			case LITERAL_Button:
			case LITERAL_Background:
			case LITERAL_BaselinePosition:
			case LITERAL_BaseStyle:
			case LITERAL_Boxed:
			case LITERAL_BoxRatios:
			case LITERAL_BoxStyle:
			case LITERAL_CapForm:
			case LITERAL_ControllerLinking:
			case LITERAL_ControllerMethod:
			case LITERAL_ControllerPath:
			case LITERAL_ColorOutput:
			case LITERAL_Dashing:
			case LITERAL_Dynamic:
			case LITERAL_DisplayFunction:
			case LITERAL_DefaultColor:
			case LITERAL_DefaultFont:
			case LITERAL_Epilog:
			case LITERAL_EventHandler:
			case LITERAL_FaceGrids:
			case LITERAL_FaceGridsStyle:
			case LITERAL_FormatType:
			case LITERAL_Hyperlink:
			case LITERAL_ImageMargins:
			case LITERAL_ImagePadding:
			case LITERAL_ImageSize:
			case LITERAL_JoinForm:
			case LITERAL_Lighting:
			case LITERAL_LightSources:
			case LITERAL_LabelStyle:
			case LITERAL_Mouseover:
			case LITERAL_Method:
			case LITERAL_Prolog:
			case LITERAL_PlotRange:
			case LITERAL_PlotRangePadding:
			case LITERAL_PlotLabel:
			case LITERAL_PlotRegion:
			case LITERAL_PointSize:
			case LITERAL_PolygonIntersections:
			case 128:
			case LITERAL_PopupWindow:
			case LITERAL_PreserveImageOptions:
			case LITERAL_RenderAll:
			case LITERAL_RotationAction:
			case LITERAL_SphericalRegion:
			case LITERAL_Shading:
			case LITERAL_Spec:
			case LITERAL_Specularity:
			case LITERAL_StatusArea:
			case LITERAL_Style:
			case LITERAL_Ticks:
			case LITERAL_TicksStyle:
			case LITERAL_Tooltip:
			case LITERAL_TextStyle:
			case LITERAL_Thickness:
			case LITERAL_ViewPoint:
			case LITERAL_ViewAngle:
			case LITERAL_ViewCenter:
			case LITERAL_ViewVertical:
			case LITERAL_ViewMatrix:
			case LITERAL_ViewRange:
			case LITERAL_ViewVector:
			{
				strange();
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void faceFormContent(
		MState state
	) throws RecognitionException, TokenStreamException {
		
		Color col;
		
		try {      // for error handling
			switch ( LA(1)) {
			case LITERAL_SurfaceColor:
			case LITERAL_Red:
			case LITERAL_Green:
			case LITERAL_Blue:
			case LITERAL_Black:
			case LITERAL_White:
			case LITERAL_Gray:
			case LITERAL_Cyan:
			case LITERAL_Magenta:
			case LITERAL_Yellow:
			case LITERAL_Brown:
			case LITERAL_Orange:
			case LITERAL_Pink:
			case LITERAL_Purple:
			case LITERAL_LightRed:
			case LITERAL_LightGreen:
			case LITERAL_LightBlue:
			case LITERAL_LightGray:
			case LITERAL_LightCyan:
			case LITERAL_LightMagenta:
			case LITERAL_LightYellow:
			case LITERAL_LightBrown:
			case LITERAL_LightOrange:
			case LITERAL_LightPink:
			case LITERAL_LightPurple:
			case LITERAL_Lighter:
			case LITERAL_Darker:
			case LITERAL_RGBColor:
			case LITERAL_Hue:
			case LITERAL_GrayLevel:
			case LITERAL_CMYKColor:
			case LITERAL_Opacity:
			case LITERAL_Directive:
			{
				col=color(state);
				state.faceColor=col;
				break;
			}
			case OPEN_BRACE:
			{
				match(OPEN_BRACE);
				{
				switch ( LA(1)) {
				case OPEN_BRACE:
				case LITERAL_SurfaceColor:
				case LITERAL_Red:
				case LITERAL_Green:
				case LITERAL_Blue:
				case LITERAL_Black:
				case LITERAL_White:
				case LITERAL_Gray:
				case LITERAL_Cyan:
				case LITERAL_Magenta:
				case LITERAL_Yellow:
				case LITERAL_Brown:
				case LITERAL_Orange:
				case LITERAL_Pink:
				case LITERAL_Purple:
				case LITERAL_LightRed:
				case LITERAL_LightGreen:
				case LITERAL_LightBlue:
				case LITERAL_LightGray:
				case LITERAL_LightCyan:
				case LITERAL_LightMagenta:
				case LITERAL_LightYellow:
				case LITERAL_LightBrown:
				case LITERAL_LightOrange:
				case LITERAL_LightPink:
				case LITERAL_LightPurple:
				case LITERAL_Lighter:
				case LITERAL_Darker:
				case LITERAL_RGBColor:
				case LITERAL_Hue:
				case LITERAL_GrayLevel:
				case LITERAL_CMYKColor:
				case LITERAL_Opacity:
				case LITERAL_Directive:
				case LITERAL_ContentSelectable:
				case LITERAL_None:
				case LITERAL_Arrow:
				case LITERAL_AbsoluteDashing:
				case LITERAL_AbsolutePointSize:
				case LITERAL_AbsoluteThickness:
				case LITERAL_Arrowheads:
				case LITERAL_Annotation:
				case LITERAL_AlignmentPoint:
				case LITERAL_AspectRatio:
				case LITERAL_Axes:
				case LITERAL_AxesEdge:
				case LITERAL_AxesLabel:
				case LITERAL_AxesOrigin:
				case LITERAL_AxesStyle:
				case LITERAL_AmbientLight:
				case LITERAL_BezierCurve:
				case LITERAL_BSplineCurve:
				case LITERAL_BSplineSurface:
				case LITERAL_Button:
				case LITERAL_Background:
				case LITERAL_BaselinePosition:
				case LITERAL_BaseStyle:
				case LITERAL_Boxed:
				case LITERAL_BoxRatios:
				case LITERAL_BoxStyle:
				case LITERAL_CapForm:
				case LITERAL_ControllerLinking:
				case LITERAL_ControllerMethod:
				case LITERAL_ControllerPath:
				case LITERAL_ColorOutput:
				case LITERAL_Dashing:
				case LITERAL_Dynamic:
				case LITERAL_DisplayFunction:
				case LITERAL_DefaultColor:
				case LITERAL_DefaultFont:
				case LITERAL_Epilog:
				case LITERAL_EventHandler:
				case LITERAL_FaceGrids:
				case LITERAL_FaceGridsStyle:
				case LITERAL_FormatType:
				case LITERAL_Hyperlink:
				case LITERAL_ImageMargins:
				case LITERAL_ImagePadding:
				case LITERAL_ImageSize:
				case LITERAL_JoinForm:
				case LITERAL_Lighting:
				case LITERAL_LightSources:
				case LITERAL_LabelStyle:
				case LITERAL_Mouseover:
				case LITERAL_Method:
				case LITERAL_Prolog:
				case LITERAL_PlotRange:
				case LITERAL_PlotRangePadding:
				case LITERAL_PlotLabel:
				case LITERAL_PlotRegion:
				case LITERAL_PointSize:
				case LITERAL_PolygonIntersections:
				case 128:
				case LITERAL_PopupWindow:
				case LITERAL_PreserveImageOptions:
				case LITERAL_RenderAll:
				case LITERAL_RotationAction:
				case LITERAL_SphericalRegion:
				case LITERAL_Shading:
				case LITERAL_Spec:
				case LITERAL_Specularity:
				case LITERAL_StatusArea:
				case LITERAL_Style:
				case LITERAL_Ticks:
				case LITERAL_TicksStyle:
				case LITERAL_Tooltip:
				case LITERAL_TextStyle:
				case LITERAL_Thickness:
				case LITERAL_ViewPoint:
				case LITERAL_ViewAngle:
				case LITERAL_ViewCenter:
				case LITERAL_ViewVertical:
				case LITERAL_ViewMatrix:
				case LITERAL_ViewRange:
				case LITERAL_ViewVector:
				{
					faceFormContent(state);
					{
					_loop129:
					do {
						if ((LA(1)==COLON)) {
							match(COLON);
							faceFormContent(state);
						}
						else {
							break _loop129;
						}
						
					} while (true);
					}
					break;
				}
				case CLOSE_BRACE:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				match(CLOSE_BRACE);
				break;
			}
			case LITERAL_ContentSelectable:
			case LITERAL_None:
			case LITERAL_Arrow:
			case LITERAL_AbsoluteDashing:
			case LITERAL_AbsolutePointSize:
			case LITERAL_AbsoluteThickness:
			case LITERAL_Arrowheads:
			case LITERAL_Annotation:
			case LITERAL_AlignmentPoint:
			case LITERAL_AspectRatio:
			case LITERAL_Axes:
			case LITERAL_AxesEdge:
			case LITERAL_AxesLabel:
			case LITERAL_AxesOrigin:
			case LITERAL_AxesStyle:
			case LITERAL_AmbientLight:
			case LITERAL_BezierCurve:
			case LITERAL_BSplineCurve:
			case LITERAL_BSplineSurface:
			case LITERAL_Button:
			case LITERAL_Background:
			case LITERAL_BaselinePosition:
			case LITERAL_BaseStyle:
			case LITERAL_Boxed:
			case LITERAL_BoxRatios:
			case LITERAL_BoxStyle:
			case LITERAL_CapForm:
			case LITERAL_ControllerLinking:
			case LITERAL_ControllerMethod:
			case LITERAL_ControllerPath:
			case LITERAL_ColorOutput:
			case LITERAL_Dashing:
			case LITERAL_Dynamic:
			case LITERAL_DisplayFunction:
			case LITERAL_DefaultColor:
			case LITERAL_DefaultFont:
			case LITERAL_Epilog:
			case LITERAL_EventHandler:
			case LITERAL_FaceGrids:
			case LITERAL_FaceGridsStyle:
			case LITERAL_FormatType:
			case LITERAL_Hyperlink:
			case LITERAL_ImageMargins:
			case LITERAL_ImagePadding:
			case LITERAL_ImageSize:
			case LITERAL_JoinForm:
			case LITERAL_Lighting:
			case LITERAL_LightSources:
			case LITERAL_LabelStyle:
			case LITERAL_Mouseover:
			case LITERAL_Method:
			case LITERAL_Prolog:
			case LITERAL_PlotRange:
			case LITERAL_PlotRangePadding:
			case LITERAL_PlotLabel:
			case LITERAL_PlotRegion:
			case LITERAL_PointSize:
			case LITERAL_PolygonIntersections:
			case 128:
			case LITERAL_PopupWindow:
			case LITERAL_PreserveImageOptions:
			case LITERAL_RenderAll:
			case LITERAL_RotationAction:
			case LITERAL_SphericalRegion:
			case LITERAL_Shading:
			case LITERAL_Spec:
			case LITERAL_Specularity:
			case LITERAL_StatusArea:
			case LITERAL_Style:
			case LITERAL_Ticks:
			case LITERAL_TicksStyle:
			case LITERAL_Tooltip:
			case LITERAL_TextStyle:
			case LITERAL_Thickness:
			case LITERAL_ViewPoint:
			case LITERAL_ViewAngle:
			case LITERAL_ViewCenter:
			case LITERAL_ViewVertical:
			case LITERAL_ViewMatrix:
			case LITERAL_ViewRange:
			case LITERAL_ViewVector:
			{
				strange();
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final void egal() throws RecognitionException, TokenStreamException {
		
		
		try {      // for error handling
			{
			_loop166:
			do {
				if ((_tokenSet_18.member(LA(1)))) {
					{
					match(_tokenSet_18);
					}
				}
				else {
					break _loop166;
				}
				
			} while (true);
			}
			{
			switch ( LA(1)) {
			case OPEN_BRACE:
			{
				match(OPEN_BRACE);
				waste();
				match(CLOSE_BRACE);
				egal();
				break;
			}
			case OPEN_BRACKET:
			{
				match(OPEN_BRACKET);
				waste();
				match(CLOSE_BRACKET);
				egal();
				break;
			}
			case LPAREN:
			{
				match(LPAREN);
				waste();
				match(RPAREN);
				egal();
				break;
			}
			case CLOSE_BRACE:
			case COLON:
			case CLOSE_BRACKET:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_10);
		}
	}
	
	private final Color  vertexColor() throws RecognitionException, TokenStreamException {
		Color c;
		
		
		MState s= new MState();
		double[] n=null;
		c=null;
		
		
		try {      // for error handling
			switch ( LA(1)) {
			case LITERAL_SurfaceColor:
			case LITERAL_Red:
			case LITERAL_Green:
			case LITERAL_Blue:
			case LITERAL_Black:
			case LITERAL_White:
			case LITERAL_Gray:
			case LITERAL_Cyan:
			case LITERAL_Magenta:
			case LITERAL_Yellow:
			case LITERAL_Brown:
			case LITERAL_Orange:
			case LITERAL_Pink:
			case LITERAL_Purple:
			case LITERAL_LightRed:
			case LITERAL_LightGreen:
			case LITERAL_LightBlue:
			case LITERAL_LightGray:
			case LITERAL_LightCyan:
			case LITERAL_LightMagenta:
			case LITERAL_LightYellow:
			case LITERAL_LightBrown:
			case LITERAL_LightOrange:
			case LITERAL_LightPink:
			case LITERAL_LightPurple:
			case LITERAL_Lighter:
			case LITERAL_Darker:
			case LITERAL_RGBColor:
			case LITERAL_Hue:
			case LITERAL_GrayLevel:
			case LITERAL_CMYKColor:
			case LITERAL_Opacity:
			case LITERAL_Directive:
			{
				c=color(s);
				break;
			}
			case OPEN_BRACE:
			{
				n=vektor();
				c=MHelper.colorToRgba(n);
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_19);
		}
		return c;
	}
	
	private final double  doubleHelp() throws RecognitionException, TokenStreamException {
		double d=0;
		
		Token  s = null;
		Token  s2 = null;
		Token  s3 = null;
		double e=0; String sig="";
		
		try {      // for error handling
			{
			switch ( LA(1)) {
			case PLUS:
			{
				match(PLUS);
				break;
			}
			case MINUS:
			{
				match(MINUS);
				sig="-";
				break;
			}
			case INTEGER_THING:
			case DOT:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			{
			switch ( LA(1)) {
			case INTEGER_THING:
			{
				s = LT(1);
				match(INTEGER_THING);
				d=Double.parseDouble(sig + s.getText());
				{
				if ((LA(1)==DOT) && (_tokenSet_20.member(LA(2))) && (_tokenSet_3.member(LA(3)))) {
					match(DOT);
					{
					if ((LA(1)==INTEGER_THING) && (_tokenSet_20.member(LA(2))) && (_tokenSet_3.member(LA(3)))) {
						s2 = LT(1);
						match(INTEGER_THING);
						d=Double.parseDouble(sig + s.getText()+ "." + s2.getText());
					}
					else if ((_tokenSet_20.member(LA(1))) && (_tokenSet_3.member(LA(2))) && (_tokenSet_4.member(LA(3)))) {
					}
					else {
						throw new NoViableAltException(LT(1), getFilename());
					}
					
					}
				}
				else if ((_tokenSet_20.member(LA(1))) && (_tokenSet_3.member(LA(2))) && (_tokenSet_4.member(LA(3)))) {
				}
				else {
					throw new NoViableAltException(LT(1), getFilename());
				}
				
				}
				break;
			}
			case DOT:
			{
				match(DOT);
				s3 = LT(1);
				match(INTEGER_THING);
				d=Double.parseDouble(sig + "0." + s3.getText());
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			{
			if ((LA(1)==STAR) && (LA(2)==HAT) && (LA(3)==MINUS||LA(3)==PLUS||LA(3)==INTEGER_THING)) {
				e=exponent_thing();
				d=d*Math.pow(10,e);
			}
			else if ((_tokenSet_20.member(LA(1))) && (_tokenSet_3.member(LA(2))) && (_tokenSet_4.member(LA(3)))) {
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			
			}
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_20);
		}
		return d;
	}
	
	private final int  exponent_thing() throws RecognitionException, TokenStreamException {
		int e;
		
		Token  s = null;
		e=0; String sig="";
		
		try {      // for error handling
			match(STAR);
			match(HAT);
			{
			switch ( LA(1)) {
			case PLUS:
			{
				match(PLUS);
				break;
			}
			case MINUS:
			{
				match(MINUS);
				sig="-";
				break;
			}
			case INTEGER_THING:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			s = LT(1);
			match(INTEGER_THING);
			e=Integer.parseInt(sig + s.getText() );
		}
		catch (RecognitionException ex) {
			reportError(ex);
			recover(ex,_tokenSet_20);
		}
		return e;
	}
	
	
	public static final String[] _tokenNames = {
		"<0>",
		"EOF",
		"<2>",
		"NULL_TREE_LOOKAHEAD",
		"OPEN_BRACE",
		"CLOSE_BRACE",
		"COLON",
		"\"Graphics3D\"",
		"OPEN_BRACKET",
		"CLOSE_BRACKET",
		"\"GraphicsGroup\"",
		"\"Cuboid\"",
		"\"Sphere\"",
		"\"Cylinder\"",
		"\"Text\"",
		"STRING",
		"\"Inset\"",
		"\"GraphicsComplex\"",
		"\"Point\"",
		"\"Line\"",
		"\"Tube\"",
		"\"Polygon\"",
		"\"SurfaceColor\"",
		"\"Red\"",
		"\"Green\"",
		"\"Blue\"",
		"\"Black\"",
		"\"White\"",
		"\"Gray\"",
		"\"Cyan\"",
		"\"Magenta\"",
		"\"Yellow\"",
		"\"Brown\"",
		"\"Orange\"",
		"\"Pink\"",
		"\"Purple\"",
		"\"LightRed\"",
		"\"LightGreen\"",
		"\"LightBlue\"",
		"\"LightGray\"",
		"\"LightCyan\"",
		"\"LightMagenta\"",
		"\"LightYellow\"",
		"\"LightBrown\"",
		"\"LightOrange\"",
		"\"LightPink\"",
		"\"LightPurple\"",
		"\"Lighter\"",
		"\"Darker\"",
		"\"RGBColor\"",
		"\"Hue\"",
		"\"GrayLevel\"",
		"\"CMYKColor\"",
		"\"Opacity\"",
		"\"Directive\"",
		"\"EdgeForm\"",
		"\"FaceForm\"",
		"\"ContentSelectable\"",
		"MINUS",
		"LARGER",
		"\"VertexColors\"",
		"\"None\"",
		"\"VertexNormals\"",
		"PLUS",
		"INTEGER_THING",
		"SLASH",
		"STAR",
		"\"I\"",
		"DOT",
		"HAT",
		"LPAREN",
		"RPAREN",
		"\"Arrow\"",
		"\"AbsoluteDashing\"",
		"\"AbsolutePointSize\"",
		"\"AbsoluteThickness\"",
		"\"Arrowheads\"",
		"\"Annotation\"",
		"\"AlignmentPoint\"",
		"\"AspectRatio\"",
		"\"Axes\"",
		"\"AxesEdge\"",
		"\"AxesLabel\"",
		"\"AxesOrigin\"",
		"\"AxesStyle\"",
		"\"AmbientLight\"",
		"\"BezierCurve\"",
		"\"BSplineCurve\"",
		"\"BSplineSurface\"",
		"\"Button\"",
		"\"Background\"",
		"\"BaselinePosition\"",
		"\"BaseStyle\"",
		"\"Boxed\"",
		"\"BoxRatios\"",
		"\"BoxStyle\"",
		"\"CapForm\"",
		"\"ControllerLinking\"",
		"\"ControllerMethod\"",
		"\"ControllerPath\"",
		"\"ColorOutput\"",
		"\"Dashing\"",
		"\"Dynamic\"",
		"\"DisplayFunction\"",
		"\"DefaultColor\"",
		"\"DefaultFont\"",
		"\"Epilog\"",
		"\"EventHandler\"",
		"\"FaceGrids\"",
		"\"FaceGridsStyle\"",
		"\"FormatType\"",
		"\"Hyperlink\"",
		"\"ImageMargins\"",
		"\"ImagePadding\"",
		"\"ImageSize\"",
		"\"JoinForm\"",
		"\"Lighting\"",
		"\"LightSources\"",
		"\"LabelStyle\"",
		"\"Mouseover\"",
		"\"Method\"",
		"\"Prolog\"",
		"\"PlotRange\"",
		"\"PlotRangePadding\"",
		"\"PlotLabel\"",
		"\"PlotRegion\"",
		"\"PointSize\"",
		"\"PolygonIntersections\"",
		"\"Plot3Matrix\"",
		"\"PopupWindow\"",
		"\"PreserveImageOptions\"",
		"\"RenderAll\"",
		"\"RotationAction\"",
		"\"SphericalRegion\"",
		"\"Shading\"",
		"\"Spec\"",
		"\"Specularity\"",
		"\"StatusArea\"",
		"\"Style\"",
		"\"Ticks\"",
		"\"TicksStyle\"",
		"\"Tooltip\"",
		"\"TextStyle\"",
		"\"Thickness\"",
		"\"ViewPoint\"",
		"\"ViewAngle\"",
		"\"ViewCenter\"",
		"\"ViewVertical\"",
		"\"ViewMatrix\"",
		"\"ViewRange\"",
		"\"ViewVector\"",
		"BACKS",
		"DOLLAR",
		"SMALER",
		"DDOT",
		"T1",
		"T2",
		"T3",
		"T4",
		"T5",
		"T6",
		"T7",
		"T8",
		"T9",
		"an identifier",
		"ID_LETTER",
		"DIGIT",
		"ESC",
		"WS_"
	};
	
	private static final long[] mk_tokenSet_0() {
		long[] data = { 2L, 0L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_0 = new BitSet(mk_tokenSet_0());
	private static final long[] mk_tokenSet_1() {
		long[] data = { 2594073385365371920L, -256L, 8388607L, 0L, 0L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_1 = new BitSet(mk_tokenSet_1());
	private static final long[] mk_tokenSet_2() {
		long[] data = new long[8];
		data[0]=-528L;
		data[1]=-129L;
		data[2]=2199023255551L;
		return data;
	}
	public static final BitSet _tokenSet_2 = new BitSet(mk_tokenSet_2());
	private static final long[] mk_tokenSet_3() {
		long[] data = new long[8];
		data[0]=-16L;
		data[1]=-129L;
		data[2]=2199023255551L;
		return data;
	}
	public static final BitSet _tokenSet_3 = new BitSet(mk_tokenSet_3());
	private static final long[] mk_tokenSet_4() {
		long[] data = new long[8];
		data[0]=-14L;
		data[1]=-1L;
		data[2]=2199023255551L;
		return data;
	}
	public static final BitSet _tokenSet_4 = new BitSet(mk_tokenSet_4());
	private static final long[] mk_tokenSet_5() {
		long[] data = { 98L, 0L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_5 = new BitSet(mk_tokenSet_5());
	private static final long[] mk_tokenSet_6() {
		long[] data = { 32L, 0L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_6 = new BitSet(mk_tokenSet_6());
	private static final long[] mk_tokenSet_7() {
		long[] data = { 544L, 0L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_7 = new BitSet(mk_tokenSet_7());
	private static final long[] mk_tokenSet_8() {
		long[] data = new long[8];
		data[0]=-832L;
		data[1]=-193L;
		data[2]=2199023255551L;
		return data;
	}
	public static final BitSet _tokenSet_8 = new BitSet(mk_tokenSet_8());
	private static final long[] mk_tokenSet_9() {
		long[] data = { 544L, 128L, 0L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_9 = new BitSet(mk_tokenSet_9());
	private static final long[] mk_tokenSet_10() {
		long[] data = { 608L, 0L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_10 = new BitSet(mk_tokenSet_10());
	private static final long[] mk_tokenSet_11() {
		long[] data = { 2594073385361211392L, -256L, 8388607L, 0L, 0L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_11 = new BitSet(mk_tokenSet_11());
	private static final long[] mk_tokenSet_12() {
		long[] data = { 2449958197289549824L, -256L, 8388607L, 0L, 0L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_12 = new BitSet(mk_tokenSet_12());
	private static final long[] mk_tokenSet_13() {
		long[] data = { 8358680908399606784L, -256L, 8388607L, 0L, 0L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_13 = new BitSet(mk_tokenSet_13());
	private static final long[] mk_tokenSet_14() {
		long[] data = { 8358680908399606800L, -256L, 8388607L, 0L, 0L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_14 = new BitSet(mk_tokenSet_14());
	private static final long[] mk_tokenSet_15() {
		long[] data = { -8935141660703064064L, 17L, 0L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_15 = new BitSet(mk_tokenSet_15());
	private static final long[] mk_tokenSet_16() {
		long[] data = { 576L, 0L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_16 = new BitSet(mk_tokenSet_16());
	private static final long[] mk_tokenSet_17() {
		long[] data = new long[8];
		data[0]=-48L;
		data[1]=-129L;
		data[2]=2199023255551L;
		return data;
	}
	public static final BitSet _tokenSet_17 = new BitSet(mk_tokenSet_17());
	private static final long[] mk_tokenSet_18() {
		long[] data = new long[8];
		data[0]=-896L;
		data[1]=-193L;
		data[2]=2199023255551L;
		return data;
	}
	public static final BitSet _tokenSet_18 = new BitSet(mk_tokenSet_18());
	private static final long[] mk_tokenSet_19() {
		long[] data = { 96L, 0L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_19 = new BitSet(mk_tokenSet_19());
	private static final long[] mk_tokenSet_20() {
		long[] data = { -8935141660703063456L, 23L, 0L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_20 = new BitSet(mk_tokenSet_20());
	
	}
