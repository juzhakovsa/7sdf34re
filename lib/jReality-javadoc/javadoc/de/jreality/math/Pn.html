<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_25) on Tue Jul 29 15:31:41 CEST 2014 -->
<title>Pn (jReality API)</title>
<meta name="date" content="2014-07-29">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Pn (jReality API)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Pn.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../de/jreality/math/P3.html" title="class in de.jreality.math"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../de/jreality/math/Quat.html" title="class in de.jreality.math"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?de/jreality/math/Pn.html" target="_top">Frames</a></li>
<li><a href="Pn.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">de.jreality.math</div>
<h2 title="Class Pn" class="title">Class Pn</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>de.jreality.math.Pn</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="strong">Pn</span>
extends <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a></pre>
<div class="block">A set of static methods related to real n-dimensional real projective space RP<sup>n</sup>.
  In general, points and vectors are represented in homogeneous coordinates by arrays of length <i>n+1</i>.  
  By duality, hyperplanes are represented in the same fashion. The last coordinate is considered 
  to be the <i>homogeneous</i> coordinate (see for example <a href="../../../de/jreality/math/Pn.html#dehomogenize(double[], double[])"><code>dehomogenize(double[], double[])</code></a>).
  <p>
  In addition to purely projective methods,
  this includes a number of methods related to the classical 
  homogeneous metric spaces (euclidean, hyperbolic, and elliptic)
  which are based on a projective model for these spaces.
  <p>
        The methods related to metric geometries generally have a final argument
 which identifies the geometry.  This can be one of the 3 pre-defined values
 <a href="../../../de/jreality/math/Pn.html#HYPERBOLIC"><code>HYPERBOLIC</code></a>, <a href="../../../de/jreality/math/Pn.html#EUCLIDEAN"><code>EUCLIDEAN</code></a>   or <a href="../../../de/jreality/math/Pn.html#ELLIPTIC"><code>ELLIPTIC</code></a>. These correspond to 
 spaces of constant negative, null, and positive curvature, resp.
  <p>
  (For the mathematical basis of the derivation of metric geometries from projective geometry 
  -- which forms the foundation the functionality of this class -- see
  H.M.S. Coxeter, Non-Euclidean Geometry, 1965.)
        <p>
  <b>Note</b>: there may appear to be some duplication of functionality with methods in <a href="../../../de/jreality/math/Rn.html" title="class in de.jreality.math"><code>Rn</code></a>. However,
  the methods here expect points to be specified with homogeneous coordinates, while those in Rn expect dehomogenized
  coordinates (in general -- but see <a href="../../../de/jreality/math/Rn.html" title="class in de.jreality.math"><code>Rn</code></a> for exceptions), so there is 
  usually only one correct choice for which method to use. But see <a href="../../../de/jreality/math/Pn.html#normalize(double[], double[], int)"><code>normalize(double[], double[], int)</code></a>
  for an example of some finer points.
  <p>
 See also <a href="../../../de/jreality/math/Rn.html" title="class in de.jreality.math"><code>Rn</code></a> for more on method conventions.
 See also <a href="../../../de/jreality/math/P2.html" title="class in de.jreality.math"><code>P2</code></a> and <a href="../../../de/jreality/math/P3.html" title="class in de.jreality.math"><code>P3</code></a> for 
 methods specific to two- and three-dimensional real projective geometry.</div>
<dl><dt><span class="strong">Author:</span></dt>
  <dd>Charles Gunn</dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#ELLIPTIC">ELLIPTIC</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#EUCLIDEAN">EUCLIDEAN</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#HYPERBOLIC">HYPERBOLIC</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#PROJECTIVE">PROJECTIVE</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#zDirectionP3">zDirectionP3</a></strong></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#acosh(double)">acosh</a></strong>(double&nbsp;x)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#angleBetween(double[], double[], int)">angleBetween</a></strong>(double[]&nbsp;u,
            double[]&nbsp;v,
            int&nbsp;metric)</code>
<div class="block">Calculate the angle between the points <i>u</i> and <i>v</i> with respect to
 the metric <i>metric</i>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#asinh(double)">asinh</a></strong>(double&nbsp;x)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#atanh(double)">atanh</a></strong>(double&nbsp;x)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#barycentricCoordinates(double[], double[][], double[])">barycentricCoordinates</a></strong>(double[]&nbsp;dst,
                      double[][]&nbsp;tri,
                      double[]&nbsp;unit)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#calculateBounds(double[][], double[][])">calculateBounds</a></strong>(double[][]&nbsp;bounds,
               double[][]&nbsp;vlist)</code>
<div class="block">Like the method <a href="../../../de/jreality/math/Rn.html#calculateBounds(double[][], double[][])"><code>calculateBounds</code></a> in class Rn, 
 but dehomogenizes the points before computing the bound.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#centroid(double[], double[][], int)">centroid</a></strong>(double[]&nbsp;average,
        double[][]&nbsp;points,
        int&nbsp;metric)</code>
<div class="block">Calculate the centroid of <i>points</i> with respect to <i>metric</i>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#coordForDistance(double, int)">coordForDistance</a></strong>(double&nbsp;d,
                int&nbsp;metric)</code>
<div class="block">Return the value <i>z</i> so that the point <i>(0,0,z,1)</i> lies a distance <i>d</i>
 from the origin <i>(0,0,0,1)</i> in the given metric.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#cosh(double)">cosh</a></strong>(double&nbsp;x)</code>
<div class="block">These hyperbolic trig functions fill in a gap in the Java math library!</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#dehomogenize(double[][], double[][])">dehomogenize</a></strong>(double[][]&nbsp;dst,
            double[][]&nbsp;src)</code>
<div class="block">A vectorized version of <a href="../../../de/jreality/math/Pn.html#dehomogenize(double[], double[])"><code>dehomogenize(double[], double[])</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#dehomogenize(double[], double[])">dehomogenize</a></strong>(double[]&nbsp;dst,
            double[]&nbsp;src)</code>
<div class="block">Dehomogenize the src array into the dst array.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#distanceBetween(double[], double[], int)">distanceBetween</a></strong>(double[]&nbsp;u,
               double[]&nbsp;v,
               int&nbsp;metric)</code>
<div class="block">Calculate the distance between the two points <i>u</i> and <i>v</i>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#dragTangentVector(double[], double[], double[], double[], double, int)">dragTangentVector</a></strong>(double[]&nbsp;dst,
                 double[]&nbsp;ddir,
                 double[]&nbsp;src,
                 double[]&nbsp;sdir,
                 double&nbsp;length,
                 int&nbsp;metric)</code>
<div class="block">Drag a tangent vector <i>sdir</i> based at point <i>src</i> with initial direction given by <i>sdir</i>, a distance
 of <i>length</i> in the given metric.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#dragTangentVector(double[], double[], double[], double[], int)">dragTangentVector</a></strong>(double[]&nbsp;dstTangent,
                 double[]&nbsp;sourcePoint,
                 double[]&nbsp;sourceTangent,
                 double[]&nbsp;dstPoint,
                 int&nbsp;metric)</code>
<div class="block">Drag the tangent vector sourceTangent based at sourcePoint to a tangent vector based at dstPoint.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#dragTowards(double[], double[], double[], double, int)">dragTowards</a></strong>(double[]&nbsp;result,
           double[]&nbsp;p0,
           double[]&nbsp;p1,
           double&nbsp;length,
           int&nbsp;metric)</code>
<div class="block">Calculate the point lying a distance length from p0 in the direction p1.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#homogenize(double[][], double[][])">homogenize</a></strong>(double[][]&nbsp;dst,
          double[][]&nbsp;src)</code>
<div class="block">A vector version of <a href="../../../de/jreality/math/Pn.html#homogenize(double[], double[])"><code>homogenize(double[], double[])</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#homogenize(double[], double[])">homogenize</a></strong>(double[]&nbsp;dst,
          double[]&nbsp;src)</code>
<div class="block">Extend the coordinates of <i>src</i> by appending 1.0</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#innerProduct(double[], double[], int)">innerProduct</a></strong>(double[]&nbsp;dst,
            double[]&nbsp;src,
            int&nbsp;metric)</code>
<div class="block">Returns the inner product of the two vectors for the given metric.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#innerProductPlanes(double[], double[], int)">innerProductPlanes</a></strong>(double[]&nbsp;dst,
                  double[]&nbsp;src,
                  int&nbsp;metric)</code>
<div class="block">The euclidean metric is not completely self-dual so we need a special method to calculate
 inner product of planes</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#innerProductPoints(double[], double[], int)">innerProductPoints</a></strong>(double[]&nbsp;dst,
                  double[]&nbsp;src,
                  int&nbsp;metric)</code>
<div class="block">An alias for <a href="../../../de/jreality/math/Pn.html#innerProduct(double[], double[], int)"><code>innerProduct(double[], double[], int)</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#isEquivalentPoints(double[], double[])">isEquivalentPoints</a></strong>(double[]&nbsp;p1,
                  double[]&nbsp;p2)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#isValidCoordinate(double[], int, int)">isValidCoordinate</a></strong>(double[]&nbsp;transVec,
                 int&nbsp;dim,
                 int&nbsp;metric)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#linearInterpolation(double[], double[], double[], double, int)">linearInterpolation</a></strong>(double[]&nbsp;dst,
                   double[]&nbsp;u,
                   double[]&nbsp;v,
                   double&nbsp;t,
                   int&nbsp;metric)</code>
<div class="block">Linear interpolate respecting the given metric <i>metric</i>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#makeFlattenProjection(double[], double[], double[])">makeFlattenProjection</a></strong>(double[]&nbsp;dst,
                     double[]&nbsp;center,
                     double[]&nbsp;axis)</code>
<div class="block">Similar to <code>P3#makeHarmonicHarmology(double[], double[], double[])</code> but maps all points
 onto the <i>axis</i> plane.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#makeGeneralizedProjection(double[], double[], double[], double)">makeGeneralizedProjection</a></strong>(double[]&nbsp;dst,
                         double[]&nbsp;center,
                         double[]&nbsp;axis,
                         double&nbsp;val)</code>
<div class="block">Create a projectivity that leaves center <i>C</i> invariant (planewise), axis <i>A</i> invariant (point-wise) and
 otherwise moves a general point P along the line <i>l</i> through P and the center depending on  
 <i>val</i>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#makeHarmonicHarmology(double[], double[], double[])">makeHarmonicHarmology</a></strong>(double[]&nbsp;dst,
                     double[]&nbsp;center,
                     double[]&nbsp;axis)</code>
<div class="block">Construct a central projectivity with fixed point center and fixed plane axis.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#midPlane(double[], double[], double[], int)">midPlane</a></strong>(double[]&nbsp;midp,
        double[]&nbsp;pl1,
        double[]&nbsp;pl2,
        int&nbsp;metric)</code>
<div class="block">Find the plane which lies, metrically, half-way between the two given planes.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#norm(double[], int)">norm</a></strong>(double[]&nbsp;src,
    int&nbsp;metric)</code>
<div class="block">Calculates the norm of the vector in the given metric <i>metric</i>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#normalize(double[][], double[][], int)">normalize</a></strong>(double[][]&nbsp;dst,
         double[][]&nbsp;src,
         int&nbsp;metric)</code>
<div class="block">A vectorized version of <a href="../../../de/jreality/math/Pn.html#normalize(double[], double[], int)"><code>normalize(double[], double[], int)</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#normalize(double[], double[], double[], double[], int)">normalize</a></strong>(double[]&nbsp;dst,
         double[]&nbsp;dvec,
         double[]&nbsp;src,
         double[]&nbsp;svec,
         int&nbsp;metric)</code>
<div class="block">Normalize a point-tangent pair <i>(src, svec)</i> so that both members have unit length
 and, the tangent vector lies in the polar plane of the point.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#normalize(double[], double[], int)">normalize</a></strong>(double[]&nbsp;dst,
         double[]&nbsp;src,
         int&nbsp;metric)</code>
<div class="block">Normalizes the vector <i>src</i> to have unit length (either 1 or <i>i</i>), or, 
 if <i>metric</i> 
 is EUCLIDEAN, then the input vector is dehomogenized.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#normalizePlane(double[], double[], int)">normalizePlane</a></strong>(double[]&nbsp;dst,
              double[]&nbsp;src,
              int&nbsp;metric)</code>
<div class="block">For the euclidean special case:
 Normalize a hyper-plane (represented as a vector of length n) so that the direction vector 
 (the first n-1 coordinates) has 
 euclidean length 1 but represents the same projective hyper-plane.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#normalizePoint(double[], double[], int)">normalizePoint</a></strong>(double[]&nbsp;dst,
              double[]&nbsp;src,
              int&nbsp;metric)</code>
<div class="block">An alias for <a href="../../../de/jreality/math/Pn.html#normalize(double[], double[], int)"><code>normalize(double[], double[], int)</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#normSquared(double[], int)">normSquared</a></strong>(double[]&nbsp;src,
           int&nbsp;metric)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#polarize(double[][], double[][], int)">polarize</a></strong>(double[][]&nbsp;polar,
        double[][]&nbsp;p,
        int&nbsp;metric)</code>
<div class="block">A vectorized version of <a href="../../../de/jreality/math/Pn.html#polarize(double[], double[], int)"><code>polarize(double[], double[], int)</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#polarize(double[], double[], int)">polarize</a></strong>(double[]&nbsp;polar,
        double[]&nbsp;p,
        int&nbsp;metric)</code>
<div class="block">Polarize the input element <i>p</i> with respect to the quadradic form associated to
  <i>metric</i>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#polarizePlane(double[], double[], int)">polarizePlane</a></strong>(double[]&nbsp;dst,
             double[]&nbsp;plane,
             int&nbsp;metric)</code>
<div class="block">This just calls <a href="../../../de/jreality/math/Pn.html#polarize(double[], double[], int)"><code>polarize(double[], double[], int)</code></a> since the polar plane of
 a point is just Q.point, where Q is the absolute quadric</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#polarizePoint(double[], double[], int)">polarizePoint</a></strong>(double[]&nbsp;dst,
             double[]&nbsp;point,
             int&nbsp;metric)</code>
<div class="block">This has to handle the exception euclidean case, that the polar of any point is
 the ideal plane.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#projectivity(double[], double[][], double[][])">projectivity</a></strong>(double[]&nbsp;dst,
            double[][]&nbsp;dm,
            double[][]&nbsp;im)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#projectivityFromCanonical(double[], double[][])">projectivityFromCanonical</a></strong>(double[]&nbsp;dst,
                         double[][]&nbsp;dm)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#projectOnto(double[], double[], double[], int)">projectOnto</a></strong>(double[]&nbsp;result,
           double[]&nbsp;master,
           double[]&nbsp;victim,
           int&nbsp;metric)</code>
<div class="block">Determine the projection of the point <i>victim</i> onto the point <i>master</i>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#projectOntoComplement(double[], double[], double[], int)">projectOntoComplement</a></strong>(double[]&nbsp;result,
                     double[]&nbsp;master,
                     double[]&nbsp;victim,
                     int&nbsp;metric)</code>
<div class="block">Project <i>victim</i> onto the othogonal complement of <i>master</i> (all with respect to the
 given metric).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#projectToTangentSpace(double[], double[], double[], int)">projectToTangentSpace</a></strong>(double[]&nbsp;result,
                     double[]&nbsp;point,
                     double[]&nbsp;tangentToBe,
                     int&nbsp;metric)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double[][]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#setToLength(double[][], double[][], double, int)">setToLength</a></strong>(double[][]&nbsp;dst,
           double[][]&nbsp;src,
           double&nbsp;d,
           int&nbsp;metric)</code>
<div class="block">A vectorized version of <a href="../../../de/jreality/math/Pn.html#setToLength(double[], double[], double, int)"><code>setToLength(double[], double[], double, int)</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#setToLength(double[], double[], double, int)">setToLength</a></strong>(double[]&nbsp;dst,
           double[]&nbsp;src,
           double&nbsp;length,
           int&nbsp;metric)</code>
<div class="block">Create a multiple of <i>src</i> with has length <i>length</i>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#sinh(double)">sinh</a></strong>(double&nbsp;x)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../../de/jreality/math/Pn.html#tanh(double)">tanh</a></strong>(double&nbsp;x)</code>&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a></h3>
<code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#equals(java.lang.Object)" title="class or interface in java.lang">equals</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#getClass()" title="class or interface in java.lang">getClass</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#hashCode()" title="class or interface in java.lang">hashCode</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#notify()" title="class or interface in java.lang">notify</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#notifyAll()" title="class or interface in java.lang">notifyAll</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#toString()" title="class or interface in java.lang">toString</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait()" title="class or interface in java.lang">wait</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait(long)" title="class or interface in java.lang">wait</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait(long, int)" title="class or interface in java.lang">wait</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="ELLIPTIC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ELLIPTIC</h4>
<pre>public static final&nbsp;int ELLIPTIC</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#de.jreality.math.Pn.ELLIPTIC">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="EUCLIDEAN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>EUCLIDEAN</h4>
<pre>public static final&nbsp;int EUCLIDEAN</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#de.jreality.math.Pn.EUCLIDEAN">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="HYPERBOLIC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HYPERBOLIC</h4>
<pre>public static final&nbsp;int HYPERBOLIC</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#de.jreality.math.Pn.HYPERBOLIC">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="PROJECTIVE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PROJECTIVE</h4>
<pre>public static final&nbsp;int PROJECTIVE</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#de.jreality.math.Pn.PROJECTIVE">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="zDirectionP3">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>zDirectionP3</h4>
<pre>public static&nbsp;double[] zDirectionP3</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="cosh(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cosh</h4>
<pre>public static&nbsp;double&nbsp;cosh(double&nbsp;x)</pre>
<div class="block">These hyperbolic trig functions fill in a gap in the Java math library!</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>arg</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd>inverse sinh of arg</dd></dl>
</li>
</ul>
<a name="sinh(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sinh</h4>
<pre>public static&nbsp;double&nbsp;sinh(double&nbsp;x)</pre>
</li>
</ul>
<a name="tanh(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tanh</h4>
<pre>public static&nbsp;double&nbsp;tanh(double&nbsp;x)</pre>
</li>
</ul>
<a name="acosh(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>acosh</h4>
<pre>public static&nbsp;double&nbsp;acosh(double&nbsp;x)</pre>
</li>
</ul>
<a name="asinh(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>asinh</h4>
<pre>public static&nbsp;double&nbsp;asinh(double&nbsp;x)</pre>
</li>
</ul>
<a name="atanh(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>atanh</h4>
<pre>public static&nbsp;double&nbsp;atanh(double&nbsp;x)</pre>
</li>
</ul>
<a name="angleBetween(double[], double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>angleBetween</h4>
<pre>public static&nbsp;double&nbsp;angleBetween(double[]&nbsp;u,
                  double[]&nbsp;v,
                  int&nbsp;metric)</pre>
<div class="block">Calculate the angle between the points <i>u</i> and <i>v</i> with respect to
 the metric <i>metric</i>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>u</code> - </dd><dd><code>v</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="calculateBounds(double[][], double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calculateBounds</h4>
<pre>public static&nbsp;double[][]&nbsp;calculateBounds(double[][]&nbsp;bounds,
                         double[][]&nbsp;vlist)</pre>
<div class="block">Like the method <a href="../../../de/jreality/math/Rn.html#calculateBounds(double[][], double[][])"><code>calculateBounds</code></a> in class Rn, 
 but dehomogenizes the points before computing the bound.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>bounds</code> - double[2][3]</dd><dd><code>vlist</code> - double[][3]     or double[][4]</dd>
<dt><span class="strong">Returns:</span></dt><dd>bounds</dd></dl>
</li>
</ul>
<a name="centroid(double[], double[][], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>centroid</h4>
<pre>public static&nbsp;double[]&nbsp;centroid(double[]&nbsp;average,
                double[][]&nbsp;points,
                int&nbsp;metric)</pre>
<div class="block">Calculate the centroid of <i>points</i> with respect to <i>metric</i>. This basically involves
 normalizing the points to have unit length with respect to the given <i>metric</i>
 before averaging them.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>average</code> - </dd><dd><code>points</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="dehomogenize(double[], double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dehomogenize</h4>
<pre>public static&nbsp;double[]&nbsp;dehomogenize(double[]&nbsp;dst,
                    double[]&nbsp;src)</pre>
<div class="block">Dehomogenize the src array into the dst array.  Both must be the same length.
 The src array is copied to the destination array if the last element of src is 0.0 or 1.0;
 otherwise each element of src is divided by the last element of src and written to the destination.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>src</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd>dst</dd></dl>
</li>
</ul>
<a name="coordForDistance(double, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>coordForDistance</h4>
<pre>public static&nbsp;double&nbsp;coordForDistance(double&nbsp;d,
                      int&nbsp;metric)</pre>
<div class="block">Return the value <i>z</i> so that the point <i>(0,0,z,1)</i> lies a distance <i>d</i>
 from the origin <i>(0,0,0,1)</i> in the given metric.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>d</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="dehomogenize(double[][], double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dehomogenize</h4>
<pre>public static&nbsp;double[][]&nbsp;dehomogenize(double[][]&nbsp;dst,
                      double[][]&nbsp;src)</pre>
<div class="block">A vectorized version of <a href="../../../de/jreality/math/Pn.html#dehomogenize(double[], double[])"><code>dehomogenize(double[], double[])</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>src</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd>dst</dd></dl>
</li>
</ul>
<a name="distanceBetween(double[], double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>distanceBetween</h4>
<pre>public static&nbsp;double&nbsp;distanceBetween(double[]&nbsp;u,
                     double[]&nbsp;v,
                     int&nbsp;metric)</pre>
<div class="block">Calculate the distance between the two points <i>u</i> and <i>v</i>. In hyperbolic
 geometry distances may be imaginary; here we only return the absolute value of the distance.
 <b>Note:</b> This method does not attempt to handle all possible special cases correctly,
 as when for example the input points lie on the Absolute Quadric, etc.  It does however handle correctly
 various cases in the hyperbolic case, when one or both of the points lie strictly outside the hyperbolic
 disk.  For example, when the first lies inside and the second outside, the method returns the metricned 
 distance of the first point to the polar line of the second (which is a hyperbolic line).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>u</code> - </dd><dd><code>v</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd>the distance</dd></dl>
</li>
</ul>
<a name="dragTangentVector(double[], double[], double[], double[], double, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dragTangentVector</h4>
<pre>public static&nbsp;double[]&nbsp;dragTangentVector(double[]&nbsp;dst,
                         double[]&nbsp;ddir,
                         double[]&nbsp;src,
                         double[]&nbsp;sdir,
                         double&nbsp;length,
                         int&nbsp;metric)</pre>
<div class="block">Drag a tangent vector <i>sdir</i> based at point <i>src</i> with initial direction given by <i>sdir</i>, a distance
 of <i>length</i> in the given metric.  
 The resulting point and tangent vector is returned in <i>ddir</i> and <i>dst</i>,
 respectively.  
 <b>Warning</b>: the source point and tangent vector are assumed to be normalized.  
 Use <a href="../../../de/jreality/math/Pn.html#normalize(double[], double[], double[], double[], int)"><code>normalize(double[], double[], double[], double[], int)</code></a> 
 to perform this normalization before calling this method.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>ddir</code> - </dd><dd><code>src</code> - </dd><dd><code>sdir</code> - </dd><dd><code>length</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="dragTangentVector(double[], double[], double[], double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dragTangentVector</h4>
<pre>public static&nbsp;double[]&nbsp;dragTangentVector(double[]&nbsp;dstTangent,
                         double[]&nbsp;sourcePoint,
                         double[]&nbsp;sourceTangent,
                         double[]&nbsp;dstPoint,
                         int&nbsp;metric)</pre>
<div class="block">Drag the tangent vector sourceTangent based at sourcePoint to a tangent vector based at dstPoint.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>ds</code> - </dd><dd><code>ds2</code> - </dd><dd><code>ds3</code> - </dd><dd><code>ds4</code> - </dd><dd><code>metric</code> - </dd><dt><span class="strong">See Also:</span></dt><dd><code>#dragTangentVector(double[], double[], double[], double, int)</code></dd></dl>
</li>
</ul>
<a name="dragTowards(double[], double[], double[], double, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dragTowards</h4>
<pre>public static&nbsp;double[]&nbsp;dragTowards(double[]&nbsp;result,
                   double[]&nbsp;p0,
                   double[]&nbsp;p1,
                   double&nbsp;length,
                   int&nbsp;metric)</pre>
<div class="block">Calculate the point lying a distance length from p0 in the direction p1. 
 p1 is first converted into a tangent vector (by projection) and then
 {@link #dragTangentVector(double[], double[], double[], double[], double, int) is then called.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>result</code> - </dd><dd><code>p0</code> - </dd><dd><code>p1</code> - </dd><dd><code>length</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="homogenize(double[], double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>homogenize</h4>
<pre>public static&nbsp;double[]&nbsp;homogenize(double[]&nbsp;dst,
                  double[]&nbsp;src)</pre>
<div class="block">Extend the coordinates of <i>src</i> by appending 1.0</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>src</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="homogenize(double[][], double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>homogenize</h4>
<pre>public static&nbsp;double[][]&nbsp;homogenize(double[][]&nbsp;dst,
                    double[][]&nbsp;src)</pre>
<div class="block">A vector version of <a href="../../../de/jreality/math/Pn.html#homogenize(double[], double[])"><code>homogenize(double[], double[])</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>src</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="innerProduct(double[], double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>innerProduct</h4>
<pre>public static&nbsp;double&nbsp;innerProduct(double[]&nbsp;dst,
                  double[]&nbsp;src,
                  int&nbsp;metric)</pre>
<div class="block">Returns the inner product of the two vectors for the given metric.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>src</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd>the inner product</dd></dl>
</li>
</ul>
<a name="innerProductPlanes(double[], double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>innerProductPlanes</h4>
<pre>public static&nbsp;double&nbsp;innerProductPlanes(double[]&nbsp;dst,
                        double[]&nbsp;src,
                        int&nbsp;metric)</pre>
<div class="block">The euclidean metric is not completely self-dual so we need a special method to calculate
 inner product of planes</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>src</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="innerProductPoints(double[], double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>innerProductPoints</h4>
<pre>public static&nbsp;double&nbsp;innerProductPoints(double[]&nbsp;dst,
                        double[]&nbsp;src,
                        int&nbsp;metric)</pre>
<div class="block">An alias for <a href="../../../de/jreality/math/Pn.html#innerProduct(double[], double[], int)"><code>innerProduct(double[], double[], int)</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>src</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="isEquivalentPoints(double[], double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isEquivalentPoints</h4>
<pre>public static&nbsp;boolean&nbsp;isEquivalentPoints(double[]&nbsp;p1,
                         double[]&nbsp;p2)</pre>
</li>
</ul>
<a name="isValidCoordinate(double[], int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isValidCoordinate</h4>
<pre>public static&nbsp;boolean&nbsp;isValidCoordinate(double[]&nbsp;transVec,
                        int&nbsp;dim,
                        int&nbsp;metric)</pre>
</li>
</ul>
<a name="linearInterpolation(double[], double[], double[], double, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>linearInterpolation</h4>
<pre>public static&nbsp;double[]&nbsp;linearInterpolation(double[]&nbsp;dst,
                           double[]&nbsp;u,
                           double[]&nbsp;v,
                           double&nbsp;t,
                           int&nbsp;metric)</pre>
<div class="block">Linear interpolate respecting the given metric <i>metric</i>.  
 That is, find the point <i>p</i> in the linear
 span of <i>u</i> and <i>v</i> such that the distance(u,p):distance(u,v) = t.  
 For the euclidean case
 this is equivalent to an ordinary linear interpolation: <i>dst = (1-t)u + tv </i>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>u</code> - </dd><dd><code>v</code> - </dd><dd><code>t</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd>dst</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../de/jreality/math/Rn.html#linearCombination(double[], double, double[], double, double[])"><code>Rn.linearCombination(double[], double, double[], double, double[]).</code></a></dd></dl>
</li>
</ul>
<a name="makeHarmonicHarmology(double[], double[], double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeHarmonicHarmology</h4>
<pre>public static&nbsp;double[]&nbsp;makeHarmonicHarmology(double[]&nbsp;dst,
                             double[]&nbsp;center,
                             double[]&nbsp;axis)</pre>
<div class="block">Construct a central projectivity with fixed point center and fixed plane axis.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>center</code> - </dd><dd><code>axis</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="makeFlattenProjection(double[], double[], double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeFlattenProjection</h4>
<pre>public static&nbsp;double[]&nbsp;makeFlattenProjection(double[]&nbsp;dst,
                             double[]&nbsp;center,
                             double[]&nbsp;axis)</pre>
<div class="block">Similar to <code>P3#makeHarmonicHarmology(double[], double[], double[])</code> but maps all points
 onto the <i>axis</i> plane.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>center</code> - </dd><dd><code>axis</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="makeGeneralizedProjection(double[], double[], double[], double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeGeneralizedProjection</h4>
<pre>public static&nbsp;double[]&nbsp;makeGeneralizedProjection(double[]&nbsp;dst,
                                 double[]&nbsp;center,
                                 double[]&nbsp;axis,
                                 double&nbsp;val)</pre>
<div class="block">Create a projectivity that leaves center <i>C</i> invariant (planewise), axis <i>A</i> invariant (point-wise) and
 otherwise moves a general point P along the line <i>l</i> through P and the center depending on  
 <i>val</i>. To be exact, let Q be the intersection of <i>l</i> with the axis.  Define projective
 coordinates on <i>l</i> by setting <i>Q,P,C</i> to 0,1,infinity  respectively. Then the projective coordinate
 of <i>f(P)</i> is <i>val</i>.  A value of 1 gives the identity, of 0 gives the projection onto the axis,
 and of infinity gives projection onto the center.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>center</code> - </dd><dd><code>axis</code> - </dd><dd><code>val</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="midPlane(double[], double[], double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>midPlane</h4>
<pre>public static&nbsp;double[]&nbsp;midPlane(double[]&nbsp;midp,
                double[]&nbsp;pl1,
                double[]&nbsp;pl2,
                int&nbsp;metric)</pre>
<div class="block">Find the plane which lies, metrically, half-way between the two given planes.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>midp</code> - </dd><dd><code>pl1</code> - </dd><dd><code>pl2</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="norm(double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>norm</h4>
<pre>public static&nbsp;double&nbsp;norm(double[]&nbsp;src,
          int&nbsp;metric)</pre>
<div class="block">Calculates the norm of the vector in the given metric <i>metric</i>.  Actually returns the absolute 
 value of the norm, since hyperbolic points can have imaginary norm.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>src</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd>the norm</dd></dl>
</li>
</ul>
<a name="normalize(double[], double[], double[], double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>normalize</h4>
<pre>public static&nbsp;double[]&nbsp;normalize(double[]&nbsp;dst,
                 double[]&nbsp;dvec,
                 double[]&nbsp;src,
                 double[]&nbsp;svec,
                 int&nbsp;metric)</pre>
<div class="block">Normalize a point-tangent pair <i>(src, svec)</i> so that both members have unit length
 and, the tangent vector lies in the polar plane of the point.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>dvec</code> - </dd><dd><code>src</code> - </dd><dd><code>svec</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="normalize(double[], double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>normalize</h4>
<pre>public static&nbsp;double[]&nbsp;normalize(double[]&nbsp;dst,
                 double[]&nbsp;src,
                 int&nbsp;metric)</pre>
<div class="block">Normalizes the vector <i>src</i> to have unit length (either 1 or <i>i</i>), or, 
 if <i>metric</i> 
 is EUCLIDEAN, then the input vector is dehomogenized.  
 To set a Euclidean vector to length 1, use
 <a href="../../../de/jreality/math/Pn.html#setToLength(double[], double[], double, int)"><code>setToLength(double[], double[], double, int)</code></a>.  
 This method is only
 valid for homogeneous coordinates. Use {@link de.jreality.math.Rn#normalize(double[], double[]) 
 if you are using dehomogenous coordinates (e.g., representing points in R3 using 3-vectors). \</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>src</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd>dst</dd></dl>
</li>
</ul>
<a name="normalize(double[][], double[][], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>normalize</h4>
<pre>public static&nbsp;double[][]&nbsp;normalize(double[][]&nbsp;dst,
                   double[][]&nbsp;src,
                   int&nbsp;metric)</pre>
<div class="block">A vectorized version of <a href="../../../de/jreality/math/Pn.html#normalize(double[], double[], int)"><code>normalize(double[], double[], int)</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>src</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="normalizePlane(double[], double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>normalizePlane</h4>
<pre>public static&nbsp;double[]&nbsp;normalizePlane(double[]&nbsp;dst,
                      double[]&nbsp;src,
                      int&nbsp;metric)</pre>
<div class="block">For the euclidean special case:
 Normalize a hyper-plane (represented as a vector of length n) so that the direction vector 
 (the first n-1 coordinates) has 
 euclidean length 1 but represents the same projective hyper-plane. Otherwise normalize to have unit length;</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>src</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="normalizePoint(double[], double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>normalizePoint</h4>
<pre>public static&nbsp;double[]&nbsp;normalizePoint(double[]&nbsp;dst,
                      double[]&nbsp;src,
                      int&nbsp;metric)</pre>
<div class="block">An alias for <a href="../../../de/jreality/math/Pn.html#normalize(double[], double[], int)"><code>normalize(double[], double[], int)</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>src</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="normSquared(double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>normSquared</h4>
<pre>public static&nbsp;double&nbsp;normSquared(double[]&nbsp;src,
                 int&nbsp;metric)</pre>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>src</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd>square of norm</dd></dl>
</li>
</ul>
<a name="polarize(double[], double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>polarize</h4>
<pre>public static&nbsp;double[]&nbsp;polarize(double[]&nbsp;polar,
                double[]&nbsp;p,
                int&nbsp;metric)</pre>
<div class="block">Polarize the input element <i>p</i> with respect to the quadradic form associated to
  <i>metric</i>.  Note: in the euclidean case, use <a href="../../../de/jreality/math/Pn.html#polarizePlane(double[], double[], int)"><code>polarizePlane(double[], double[], int)</code></a> or
  <a href="../../../de/jreality/math/Pn.html#polarizePlane(double[], double[], int)"><code>polarizePlane(double[], double[], int)</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>polar</code> - </dd><dd><code>p</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="polarize(double[][], double[][], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>polarize</h4>
<pre>public static&nbsp;double[][]&nbsp;polarize(double[][]&nbsp;polar,
                  double[][]&nbsp;p,
                  int&nbsp;metric)</pre>
<div class="block">A vectorized version of <a href="../../../de/jreality/math/Pn.html#polarize(double[], double[], int)"><code>polarize(double[], double[], int)</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>polar</code> - </dd><dd><code>p</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="polarizePlane(double[], double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>polarizePlane</h4>
<pre>public static&nbsp;double[]&nbsp;polarizePlane(double[]&nbsp;dst,
                     double[]&nbsp;plane,
                     int&nbsp;metric)</pre>
<div class="block">This just calls <a href="../../../de/jreality/math/Pn.html#polarize(double[], double[], int)"><code>polarize(double[], double[], int)</code></a> since the polar plane of
 a point is just Q.point, where Q is the absolute quadric</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>ds</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="polarizePoint(double[], double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>polarizePoint</h4>
<pre>public static&nbsp;double[]&nbsp;polarizePoint(double[]&nbsp;dst,
                     double[]&nbsp;point,
                     int&nbsp;metric)</pre>
<div class="block">This has to handle the exception euclidean case, that the polar of any point is
 the ideal plane. Otherwise it just returns <a href="../../../de/jreality/math/Pn.html#polarize(double[], double[], int)"><code>polarize(double[], double[], int)</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>object</code> - </dd><dd><code>ds</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="projectivityFromCanonical(double[], double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>projectivityFromCanonical</h4>
<pre>public static&nbsp;double[]&nbsp;projectivityFromCanonical(double[]&nbsp;dst,
                                 double[][]&nbsp;dm)</pre>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>domainPts</code> - </dd><dd><code>imagePts</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="projectivity(double[], double[][], double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>projectivity</h4>
<pre>public static&nbsp;double[]&nbsp;projectivity(double[]&nbsp;dst,
                    double[][]&nbsp;dm,
                    double[][]&nbsp;im)</pre>
</li>
</ul>
<a name="projectOnto(double[], double[], double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>projectOnto</h4>
<pre>public static&nbsp;double[]&nbsp;projectOnto(double[]&nbsp;result,
                   double[]&nbsp;master,
                   double[]&nbsp;victim,
                   int&nbsp;metric)</pre>
<div class="block">Determine the projection of the point <i>victim</i> onto the point <i>master</i>.  
 This is orthogonal projection with respect to the metric associated to <i>metric</i>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>result</code> - </dd><dd><code>master</code> - </dd><dd><code>victim</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="projectOntoComplement(double[], double[], double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>projectOntoComplement</h4>
<pre>public static&nbsp;double[]&nbsp;projectOntoComplement(double[]&nbsp;result,
                             double[]&nbsp;master,
                             double[]&nbsp;victim,
                             int&nbsp;metric)</pre>
<div class="block">Project <i>victim</i> onto the othogonal complement of <i>master</i> (all with respect to the
 given metric). See <a href="../../../de/jreality/math/Pn.html#projectOnto(double[], double[], double[], int)"><code>projectOnto(double[], double[], double[], int)</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>result</code> - </dd><dd><code>master</code> - </dd><dd><code>victim</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="projectToTangentSpace(double[], double[], double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>projectToTangentSpace</h4>
<pre>public static&nbsp;double[]&nbsp;projectToTangentSpace(double[]&nbsp;result,
                             double[]&nbsp;point,
                             double[]&nbsp;tangentToBe,
                             int&nbsp;metric)</pre>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>result</code> - </dd><dd><code>point</code> - </dd><dd><code>tangentToBe</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="setToLength(double[], double[], double, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setToLength</h4>
<pre>public static&nbsp;double[]&nbsp;setToLength(double[]&nbsp;dst,
                   double[]&nbsp;src,
                   double&nbsp;length,
                   int&nbsp;metric)</pre>
<div class="block">Create a multiple of <i>src</i> with has length <i>length</i>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dst</code> - </dd><dd><code>src</code> - </dd><dd><code>length</code> - </dd><dd><code>metric</code> - </dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="setToLength(double[][], double[][], double, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setToLength</h4>
<pre>public static&nbsp;double[][]&nbsp;setToLength(double[][]&nbsp;dst,
                     double[][]&nbsp;src,
                     double&nbsp;d,
                     int&nbsp;metric)</pre>
<div class="block">A vectorized version of <a href="../../../de/jreality/math/Pn.html#setToLength(double[], double[], double, int)"><code>setToLength(double[], double[], double, int)</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>verts</code> - </dd><dd><code>verts2</code> - </dd><dd><code>d</code> - </dd><dd><code>euclidean2</code> - </dd></dl>
</li>
</ul>
<a name="barycentricCoordinates(double[], double[][], double[])">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>barycentricCoordinates</h4>
<pre>public static&nbsp;double[]&nbsp;barycentricCoordinates(double[]&nbsp;dst,
                              double[][]&nbsp;tri,
                              double[]&nbsp;unit)</pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Pn.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../de/jreality/math/P3.html" title="class in de.jreality.math"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../de/jreality/math/Quat.html" title="class in de.jreality.math"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?de/jreality/math/Pn.html" target="_top">Frames</a></li>
<li><a href="Pn.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
